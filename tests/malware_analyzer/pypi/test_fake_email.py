# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""Tests for the FakeEmailAnalyzer heuristic."""


from collections.abc import Generator
from unittest.mock import MagicMock, patch

import pytest
from email_validator import EmailNotValidError

from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult
from macaron.malware_analyzer.pypi_heuristics.metadata.fake_email import FakeEmailAnalyzer
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIPackageJsonAsset


@pytest.fixture(name="analyzer")
def analyzer_() -> FakeEmailAnalyzer:
    """Pytest fixture to create a FakeEmailAnalyzer instance."""
    return FakeEmailAnalyzer()


@pytest.fixture(name="pypi_package_json_asset_mock")
def pypi_package_json_asset_mock_fixture() -> MagicMock:
    """Pytest fixture for a mock PyPIPackageJsonAsset."""
    mock_asset = MagicMock(spec=PyPIPackageJsonAsset)
    mock_asset.package_json = {}
    return mock_asset


@pytest.fixture(name="mock_validate_email")
def mock_validate_email_fixture() -> Generator[MagicMock]:
    """Patch validate_email and mock its behavior."""
    with patch("macaron.malware_analyzer.pypi_heuristics.metadata.fake_email.validate_email") as mock:
        yield mock


def test_analyze_skip_no_emails_present(analyzer: FakeEmailAnalyzer, pypi_package_json_asset_mock: MagicMock) -> None:
    """Test the analyzer skips if no author_email or maintainer_email is present."""
    pypi_package_json_asset_mock.package_json = {"info": {"author_email": None, "maintainer_email": None}}
    result, info = analyzer.analyze(pypi_package_json_asset_mock)
    assert result == HeuristicResult.SKIP
    assert info["message"] == "No author or maintainer email available."


def test_analyze_skip_no_info_key(analyzer: FakeEmailAnalyzer, pypi_package_json_asset_mock: MagicMock) -> None:
    """Test the analyzer skips if 'info' key is missing in PyPI data."""
    pypi_package_json_asset_mock.package_json = {}  # No 'info' key
    result, info = analyzer.analyze(pypi_package_json_asset_mock)
    assert result == HeuristicResult.SKIP
    assert info["message"] == "No package info available."


def test_analyze_fail_invalid_email(
    analyzer: FakeEmailAnalyzer, pypi_package_json_asset_mock: MagicMock, mock_validate_email: MagicMock
) -> None:
    """Test analyzer fails for an invalid email format."""
    invalid_email = "invalid-email"
    pypi_package_json_asset_mock.package_json = {"info": {"author_email": invalid_email, "maintainer_email": None}}
    mock_validate_email.side_effect = EmailNotValidError("Invalid email.")

    result, info = analyzer.analyze(pypi_package_json_asset_mock)

    assert result == HeuristicResult.FAIL
    assert info == {"email": invalid_email}
    mock_validate_email.assert_called_once_with(invalid_email, check_deliverability=True)


def test_analyze_pass_only_maintainer_email_valid(
    analyzer: FakeEmailAnalyzer, pypi_package_json_asset_mock: MagicMock, mock_validate_email: MagicMock
) -> None:
    """Test analyzer passes when only maintainer_email is present and valid."""
    email = "maintainer@example.net"
    pypi_package_json_asset_mock.package_json = {"info": {"author_email": None, "maintainer_email": email}}

    mock_email_info = MagicMock()
    mock_email_info.normalized = "maintainer@example.net"
    mock_email_info.local_part = "maintainer"
    mock_email_info.domain = "example.net"
    mock_validate_email.return_value = mock_email_info

    result, info = analyzer.analyze(pypi_package_json_asset_mock)
    assert result == HeuristicResult.PASS
    assert info["validated_emails"] == [
        {"normalized": "maintainer@example.net", "local_part": "maintainer", "domain": "example.net"}
    ]
    mock_validate_email.assert_called_once_with(email, check_deliverability=True)


def test_analyze_pass_both_emails_valid(
    analyzer: FakeEmailAnalyzer, pypi_package_json_asset_mock: MagicMock, mock_validate_email: MagicMock
) -> None:
    """Test the analyzer passes when both emails are present and valid."""

    def side_effect(email: str, check_deliverability: bool) -> MagicMock:  # pylint: disable=unused-argument
        local_part, domain = email.split("@")
        mock_email_info = MagicMock()
        mock_email_info.normalized = email
        mock_email_info.local_part = local_part
        mock_email_info.domain = domain
        return mock_email_info

    mock_validate_email.side_effect = side_effect

    pypi_package_json_asset_mock.package_json = {
        "info": {"author_email": "author@example.com", "maintainer_email": "maintainer@example.net"}
    }
    result, info = analyzer.analyze(pypi_package_json_asset_mock)
    assert result == HeuristicResult.PASS
    assert mock_validate_email.call_count == 2

    validated_emails = info.get("validated_emails")
    assert isinstance(validated_emails, list)
    assert len(validated_emails) == 2
    assert {"normalized": "author@example.com", "local_part": "author", "domain": "example.com"} in validated_emails
    assert {
        "normalized": "maintainer@example.net",
        "local_part": "maintainer",
        "domain": "example.net",
    } in validated_emails


def test_is_valid_email_success(analyzer: FakeEmailAnalyzer, mock_validate_email: MagicMock) -> None:
    """Test is_valid_email returns the validation object on success."""
    mock_validated_email = MagicMock()
    mock_validated_email.normalized = "test@example.com"
    mock_validated_email.local_part = "test"
    mock_validated_email.domain = "example.com"

    mock_validate_email.return_value = mock_validated_email
    result = analyzer.is_valid_email("test@example.com")
    assert result == mock_validated_email
    mock_validate_email.assert_called_once_with("test@example.com", check_deliverability=True)


def test_is_valid_email_failure(analyzer: FakeEmailAnalyzer, mock_validate_email: MagicMock) -> None:
    """Test is_valid_email returns None on failure."""
    mock_validate_email.side_effect = EmailNotValidError("The email address is not valid.")
    result = analyzer.is_valid_email("invalid-email")
    assert result is None
    mock_validate_email.assert_called_once_with("invalid-email", check_deliverability=True)
