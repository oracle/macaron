# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""Tests detecting malicious patterns in PyPI package sourcecode."""
import json
import os
from pathlib import Path
from unittest.mock import MagicMock

import pytest
import yaml

from macaron import MACARON_PATH
from macaron.config.defaults import defaults, load_defaults
from macaron.errors import ConfigurationError, HeuristicAnalyzerValueError
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult
from macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer import PyPISourcecodeAnalyzer

RESOURCES_PATH = os.path.join(MACARON_PATH, "resources")


def config_defaults(tmp_path: Path, content: str) -> None:
    """Set up the global defaults variable with the given defaults.ini content.

    Parameters
    ----------
    tmp_path: Path
        Pytest temporary path fixture.
    content: str
        The content of the defaults.init file.
    """
    defaults_file = Path(os.path.join(tmp_path, "config.ini"))
    defaults_file.write_text(content, encoding="utf-8")
    assert load_defaults(str(defaults_file)) is True


def get_rule_ids_list(path: str) -> set[str]:
    """
    Extract a set of Semgrep rule IDs from a .yaml file.

    Parameters
    ----------
    path: str
        The path to the .yaml file to read.

    Returns
    -------
    set[str]
        Extracted set of rule IDs from the .yaml file provided.
    """
    with open(path, encoding="utf8") as semgrep_yaml:
        ruleset: dict[str, list] = yaml.safe_load(semgrep_yaml.read())
    return {rule["id"] for rule in ruleset["rules"]}


def test_no_resources() -> None:
    """Test for when the semgrep rules can't be found (should error)."""
    with pytest.raises(ConfigurationError):
        _ = PyPISourcecodeAnalyzer(resources_path="")


def test_no_defaults_section() -> None:
    """Test for when the heuristics.pypi in defaults isn't defined at all (should error).

    This is more so a coverage internal test, and can't really happen when a user provides their own config.ini.
    """
    # have to manually remove the section as providing a file won't remove the section
    defaults.remove_section("heuristic.pypi")
    with pytest.raises(ConfigurationError):
        _ = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)


def test_no_sourcecode(pypi_package_json: MagicMock) -> None:
    """Test for when there is no source code available (should error).

    Parameters
    ----------
    pypi_package_json: MagicMock
        The PyPIPackageJsonAsset MagicMock fixture.
    """
    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)

    pypi_package_json.package_sourcecode_path = ""

    with pytest.raises(HeuristicAnalyzerValueError):
        analyzer.analyze(pypi_package_json)


def test_no_custom_path(tmp_path: Path) -> None:
    """Test for when a default path isn't provided (the custom rule path should be None).

    Parameters
    ----------
    tmp_path: Path
        Pytest temporary path fixture.
    """
    defaults_content = """
    [heuristic.pypi]
    custom_semgrep_rules_path =
    """
    config_defaults(tmp_path, defaults_content)
    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    assert analyzer.custom_rule_path is None


def test_nonexistent_rule_path(tmp_path: Path) -> None:
    """Test for when the custom path provided does not exist (should error).

    Parameters
    ----------
    tmp_path: Path
        Pytest temporary path fixture.
    """
    defaults_content = """
    [heuristic.pypi]
    custom_semgrep_rules_path = some_random_path
    """
    config_defaults(tmp_path, defaults_content)
    with pytest.raises(ConfigurationError):
        _ = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)


def test_invalid_custom_rules(tmp_path: Path, pypi_package_json: MagicMock) -> None:
    """Test for when the provided file is not a valid semgrep rule (should error).

    Parameters
    ----------
    tmp_path: Path
        Pytest temporary path fixture.
    pypi_package_json: MagicMock
        The PyPIPackageJsonAsset MagicMock fixture.
    """
    # Use this file as an invalid semgrep rule as it is most definitely not a semgrep rule, and does exist.
    defaults_content = f"""
    [heuristic.pypi]
    custom_semgrep_rules_path = {os.path.abspath(__file__)}
    """
    config_defaults(tmp_path, defaults_content)

    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    pypi_package_json.package_sourcecode_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "resources", "sourcecode_samples"
    )

    # Semgrep should fail to run when we launch analysis
    with pytest.raises(HeuristicAnalyzerValueError):
        _ = analyzer.analyze(pypi_package_json)


@pytest.mark.parametrize(
    # the sourcecode sample directory under resources/sourcecode_samples and the semgrep rule under resources/pypi_malware_rules
    ("sourcecode_sample_dir", "rule_file"),
    [
        pytest.param("obfuscation", "obfuscation.yaml", id="obfuscation"),
        pytest.param("exfiltration", "exfiltration.yaml", id="exfiltration"),
    ],
)
def test_rules(pypi_package_json: MagicMock, sourcecode_sample_dir: str, rule_file: str) -> None:
    """Test the default Semgrep rulesets on suspicious code samples (should fail).

    Parameters
    ----------
    pypi_package_json: MagicMock
        The PyPIPackageJsonAsset MagicMock fixture.
    sourcecode_sample_dir: str
        The directory name in the test resources directory containing sample suspicious code and an expected_results.json file.
    rule_file: str
        The file name (with extension) of the ruleset from the main resources directory to test.
    """
    sample_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "resources", "sourcecode_samples", sourcecode_sample_dir
    )

    with open(os.path.join(sample_path, "expected_results.json"), encoding="utf-8") as file:
        expected_results = json.loads(file.read())

    # Test with none of the defaults.ini settings used, to ensure this ruleset is run
    defaults["heuristic.pypi"].clear()

    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)

    pypi_package_json.package_sourcecode_path = sample_path
    analyzer.default_rule_path = os.path.join(analyzer.default_rule_path, rule_file)

    result, analysis = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL
    assert expected_results == analysis


def test_custom_rules(pypi_package_json: MagicMock) -> None:
    """Test that custom rulesets are properly run and appear in output detections (heuristic should fail).

    Parameters
    ----------
    pypi_package_json: MagicMock
        The PyPIPackageJsonAsset MagicMock fixture.
    """
    custom_rule_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources", "custom_sample.yaml")
    expected_ids = get_rule_ids_list(custom_rule_path)

    defaults["heuristic.pypi"]["custom_semgrep_rules_path"] = custom_rule_path

    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    pypi_package_json.package_sourcecode_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "resources", "sourcecode_samples"
    )

    result, analysis = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL

    # ensure the type is correct
    assert isinstance(analysis["enabled_sourcecode_rule_findings"], dict)
    assert all(isinstance(k, str) for k in analysis["enabled_sourcecode_rule_findings"])

    actual_ids = {rule_id.split(".")[-1] for rule_id in analysis["enabled_sourcecode_rule_findings"]}
    assert expected_ids - actual_ids == set()


def test_disabling_rulesets(
    tmp_path: Path,
    pypi_package_json: MagicMock,
) -> None:
    """Test that rulesets can be disabled (heuristic should fail).

    Parameters
    ----------
    tmp_path: Path
        Pytest temporary path fixture.
    pypi_package_json: MagicMock
        The PyPIPackageJsonAsset MagicMock fixture.
    """
    # ensure both custom and default rulesets can be disabled
    expected_ids = get_rule_ids_list(os.path.join(RESOURCES_PATH, "pypi_malware_rules", "obfuscation.yaml"))
    expected_ids.union(
        get_rule_ids_list(os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources", "custom_sample.yaml"))
    )

    defaults_content = f"""
    [heuristic.pypi]
    disabled_default_rulesets = obfuscation
    disabled_custom_rulesets = custom_sample
    custom_semgrep_rules_path = {os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources")}
    """
    config_defaults(tmp_path, defaults_content)

    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    pypi_package_json.package_sourcecode_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "resources", "sourcecode_samples"
    )

    result, analysis = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL

    # ensure the type is correct
    assert isinstance(analysis["disabled_sourcecode_rule_findings"], dict)
    assert all(isinstance(k, str) for k in analysis["disabled_sourcecode_rule_findings"])

    actual_ids = {rule_id.split(".")[-1] for rule_id in analysis["disabled_sourcecode_rule_findings"]}
    assert expected_ids - actual_ids == set()


def test_unknown_ruleset_exclusions(tmp_path: Path) -> None:
    """Test when there are ruleset names supplied to be disabled that don't exist (should error).

    Parameters
    ----------
    tmp_path: Path
        Pytest temporary path fixture.
    """
    defaults_content = f"""
    [heuristic.pypi]
    disabled_custom_rulesets =
        custom_sample
        does_not_exist
    custom_semgrep_rules_path = {os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources")}
    """
    config_defaults(tmp_path, defaults_content)

    with pytest.raises(ConfigurationError):
        _ = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)


def test_disabling_rules(tmp_path: Path, pypi_package_json: MagicMock) -> None:
    """Test individual rules can be disabled (heuristic should fail).

    Parameters
    ----------
    tmp_path: Path
        Pytest temporary path fixture.
    pypi_package_json: MagicMock
        The PyPIPackageJsonAsset MagicMock fixture.
    """
    expected_ids = {"custom_sample_1", "exfiltration_remote-exfiltration"}
    defaults_content = f"""
    [heuristic.pypi]
    custom_semgrep_rules_path = {os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources", "custom_sample.yaml")}
    disabled_rules =
        custom_sample_1
        exfiltration_remote-exfiltration
    """
    config_defaults(tmp_path, defaults_content)

    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    pypi_package_json.package_sourcecode_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "resources", "sourcecode_samples"
    )

    result, analysis = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL

    # ensure the type is correct
    assert isinstance(analysis["disabled_sourcecode_rule_findings"], dict)
    assert all(isinstance(k, str) for k in analysis["disabled_sourcecode_rule_findings"])

    actual_ids = {rule_id.split(".")[-1] for rule_id in analysis["disabled_sourcecode_rule_findings"]}
    assert expected_ids - actual_ids == set()
