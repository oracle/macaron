# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""Tests detecting malicious patterns in PyPI package sourcecode."""
import json
import os
from unittest.mock import MagicMock, patch

import pytest
import yaml

from macaron import MACARON_PATH
from macaron.errors import ConfigurationError, HeuristicAnalyzerValueError
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult
from macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer import PyPISourcecodeAnalyzer

RESOURCES_PATH = os.path.join(MACARON_PATH, "resources")


def get_rule_ids_list(path: str) -> set[str]:
    """
    Extract a set of Semgrep rule IDs from a .yaml file.

    Parameters
    ----------
    path: str
        the path to the .yaml file to read.
    """
    with open(path, encoding="utf8") as semgrep_yaml:
        ruleset: dict[str, list] = yaml.safe_load(semgrep_yaml.read())
    return {rule["id"] for rule in ruleset["rules"]}


def test_no_resources() -> None:
    """Test for when the semgrep rules can't be found, so error."""
    with pytest.raises(ConfigurationError):
        _ = PyPISourcecodeAnalyzer(resources_path="")


@patch("macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer.defaults")
def test_no_defaults_section(mock_defaults: MagicMock) -> None:
    """Test for when the heuristics.pypi in defaults isn't defined at all, so error."""
    mock_defaults.has_section.side_effect = lambda _: False
    with pytest.raises(ConfigurationError):
        _ = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)


def test_no_sourcecode(pypi_package_json: MagicMock) -> None:
    """Test for when there is no source code available, so error."""
    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)

    pypi_package_json.package_sourcecode_path = ""

    with pytest.raises(HeuristicAnalyzerValueError):
        analyzer.analyze(pypi_package_json)


@patch("macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer.defaults")
def test_no_custom_path(mock_defaults: MagicMock) -> None:
    """Test for when a default path isn't provided, so the custom rule path should be None."""
    mock_defaults.has_section.side_effect = lambda section: section == "heuristic.pypi"
    mock_defaults.__getitem__.side_effect = lambda section: (
        MagicMock(get=lambda _: None) if section == "heuristic.pypi" else None
    )
    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    assert analyzer.custom_rule_path is None

    # Make sure the empty string is not considered as a path
    mock_defaults.has_section.side_effect = lambda section: section == "heuristic.pypi"
    mock_defaults.__getitem__.side_effect = lambda section: (
        MagicMock(get=lambda _: "") if section == "heuristic.pypi" else None
    )
    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    assert analyzer.custom_rule_path is None


@patch("macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer.defaults")
def test_nonexistent_rule_path(mock_defaults: MagicMock) -> None:
    """Test for when the custom path provided does not exist, so error."""
    defaults = {
        "custom_semgrep_rules_path": "some_random_path",
    }
    sub_section = MagicMock()
    sub_section.get.side_effect = defaults.get

    mock_defaults.has_section.side_effect = lambda section: section == "heuristic.pypi"
    mock_defaults.__getitem__.side_effect = lambda section: sub_section if section == "heuristic.pypi" else None

    with pytest.raises(ConfigurationError):
        _ = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)


@patch("macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer.defaults")
def test_invalid_custom_rules(mock_defaults: MagicMock) -> None:
    """Test for when the provided file is not a valid semgrep rule, so error,"""
    # use this file as an invalid semgrep rule as it is most definitely not a semgrep rule, and does exist
    defaults = {
        "custom_semgrep_rules_path": os.path.abspath(__file__),
    }
    sub_section = MagicMock()
    sub_section.get.side_effect = defaults.get

    mock_defaults.has_section.side_effect = lambda section: section == "heuristic.pypi"
    mock_defaults.__getitem__.side_effect = lambda section: sub_section if section == "heuristic.pypi" else None

    with pytest.raises(ConfigurationError):
        _ = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)


@patch("macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer.defaults")
@pytest.mark.parametrize(
    # the sourcecode sample directory under resources/sourcecode_samples and the semgrep rule under resources/pypi_malware_rules
    ("sourcecode_sample_dir", "rule_file"),
    [
        pytest.param("obfuscation", "obfuscation.yaml", id="obfuscation"),
        pytest.param("exfiltration", "exfiltration.yaml", id="exfiltration"),
    ],
)
def test_rules(
    mock_defaults: MagicMock, pypi_package_json: MagicMock, sourcecode_sample_dir: str, rule_file: str
) -> None:
    """Test the default Semgrep rulesets on code samples."""
    sample_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)), "resources", "sourcecode_samples", sourcecode_sample_dir
    )

    with open(os.path.join(sample_path, "expected_results.json"), encoding="utf-8") as file:
        expected_results = json.loads(file.read())

    # Test with none of the defaults.ini settings used, to ensure this ruleset is run
    mock_defaults.has_section.side_effect = lambda section: section == "heuristic.pypi"
    mock_defaults.__getitem__.side_effect = lambda section: (
        MagicMock(get=lambda _: None) if section == "heuristic.pypi" else None
    )

    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)

    pypi_package_json.package_sourcecode_path = sample_path
    analyzer.default_rule_path = os.path.join(analyzer.default_rule_path, rule_file)

    result, analysis = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL
    assert expected_results == analysis


@patch("macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer.defaults")
def test_custom_rules(mock_defaults: MagicMock, pypi_package_json: MagicMock) -> None:
    """Test that custom rulesets are properly run and appear in output detections"""
    sample_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources", "sourcecode_samples")
    custom_rule_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources", "custom_sample.yaml")
    expected_ids = get_rule_ids_list(custom_rule_path)

    defaults = {
        "custom_semgrep_rules_path": custom_rule_path,
    }
    sub_section = MagicMock()
    sub_section.get.side_effect = defaults.get

    mock_defaults.has_section.side_effect = lambda section: section == "heuristic.pypi"
    mock_defaults.__getitem__.side_effect = lambda section: sub_section if section == "heuristic.pypi" else None

    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    pypi_package_json.package_sourcecode_path = sample_path

    result, analysis = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL

    # ensure the type is correct
    assert isinstance(analysis["enabled_sourcecode_rule_findings"], dict)
    assert all(isinstance(k, str) for k in analysis["enabled_sourcecode_rule_findings"])

    actual_ids = {rule_id.split(".")[-1] for rule_id in analysis["enabled_sourcecode_rule_findings"]}
    assert expected_ids - actual_ids == set()


@patch("macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer.defaults")
@pytest.mark.parametrize(
    # the sourcecode sample directory under resources/sourcecode_samples and the semgrep rule under resources/pypi_malware_rules
    ("defaults", "list_keys", "rulefile_path"),
    [
        pytest.param(
            {"disabled_default_rulesets": "obfuscation"},
            {"disabled_default_rulesets"},
            os.path.join(RESOURCES_PATH, "pypi_malware_rules", "obfuscation.yaml"),
            id="test_disable_default_ruleset",
        ),
        pytest.param(
            {
                "disabled_custom_rulesets": "custom_sample",
                "custom_semgrep_rules_path": os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources"),
            },
            {"disabled_custom_rulesets"},
            os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources", "custom_sample.yaml"),
            id="test_disable_custom_ruleset",
        ),
    ],
)
def test_disabling_rulesets(
    mock_defaults: MagicMock,
    pypi_package_json: MagicMock,
    defaults: dict[str, str],
    list_keys: set[str],
    rulefile_path: str,
) -> None:
    """Test that rulesets can be disabled"""
    sample_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources", "sourcecode_samples")

    expected_ids = get_rule_ids_list(rulefile_path)
    sub_section = MagicMock()
    sub_section.get.side_effect = defaults.get

    mock_defaults.has_section.side_effect = lambda section: section == "heuristic.pypi"
    mock_defaults.__getitem__.side_effect = lambda section: sub_section if section == "heuristic.pypi" else None
    mock_defaults.get_list.side_effect = lambda section, option: (
        [x.strip() for x in defaults[option].split("\n") if x.strip()]
        if section == "heuristic.pypi" and option in list_keys
        else None
    )

    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    pypi_package_json.package_sourcecode_path = sample_path

    result, analysis = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL

    # ensure the type is correct
    assert isinstance(analysis["disabled_sourcecode_rule_findings"], dict)
    assert all(isinstance(k, str) for k in analysis["disabled_sourcecode_rule_findings"])

    actual_ids = {rule_id.split(".")[-1] for rule_id in analysis["disabled_sourcecode_rule_findings"]}
    assert expected_ids - actual_ids == set()


@patch("macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer.defaults")
def test_unknown_ruleset_exclusions(mock_defaults: MagicMock) -> None:
    """Test when there are ruleset names supplied to be disabled that don't exist"""
    defaults = {
        "disabled_custom_rulesets": "custom_sample\ndoes_not_exist",
        "custom_semgrep_rules_path": os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources"),
    }
    sub_section = MagicMock()
    sub_section.get.side_effect = defaults.get

    mock_defaults.has_section.side_effect = lambda section: section == "heuristic.pypi"
    mock_defaults.__getitem__.side_effect = lambda section: sub_section if section == "heuristic.pypi" else None
    mock_defaults.get_list.side_effect = lambda section, option: (
        [x.strip() for x in defaults[option].split("\n") if x.strip()]
        if section == "heuristic.pypi" and option == "disabled_custom_rulesets"
        else None
    )

    with pytest.raises(ConfigurationError):
        _ = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)


@patch("macaron.malware_analyzer.pypi_heuristics.sourcecode.pypi_sourcecode_analyzer.defaults")
def test_disabling_rules(mock_defaults: MagicMock, pypi_package_json: MagicMock) -> None:
    """Test individual rules can be disabled"""
    sample_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources", "sourcecode_samples")
    custom_rule_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "resources", "custom_sample.yaml")
    expected_ids = {"custom_sample_1", "exfiltration_remote-exfiltration"}

    defaults: dict[str, str] = {
        "custom_semgrep_rules_path": custom_rule_path,
        "disabled_rules": "\n".join(expected_ids),
    }
    sub_section = MagicMock()
    sub_section.get.side_effect = defaults.get

    mock_defaults.has_section.side_effect = lambda section: section == "heuristic.pypi"
    mock_defaults.__getitem__.side_effect = lambda section: sub_section if section == "heuristic.pypi" else None
    mock_defaults.get_list.side_effect = lambda section, option: (
        list(expected_ids) if section == "heuristic.pypi" and option == "disabled_rules" else None
    )
    analyzer = PyPISourcecodeAnalyzer(resources_path=RESOURCES_PATH)
    pypi_package_json.package_sourcecode_path = sample_path

    result, analysis = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL

    # ensure the type is correct
    assert isinstance(analysis["disabled_sourcecode_rule_findings"], dict)
    assert all(isinstance(k, str) for k in analysis["disabled_sourcecode_rule_findings"])

    actual_ids = {rule_id.split(".")[-1] for rule_id in analysis["disabled_sourcecode_rule_findings"]}
    assert expected_ids - actual_ids == set()
