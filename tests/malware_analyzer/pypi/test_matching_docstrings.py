# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""Tests for the MatchingDocstringsAnalyzer heuristic."""

from unittest.mock import MagicMock, patch

import pytest

from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult
from macaron.malware_analyzer.pypi_heuristics.sourcecode.matching_docstrings import MatchingDocstringsAnalyzer, Result


@pytest.fixture(name="analyzer")
def analyzer_() -> MatchingDocstringsAnalyzer:
    """Pytest fixture to create a MatchingDocstringsAnalyzer instance."""
    return MatchingDocstringsAnalyzer()


@pytest.fixture(autouse=True)
def skip_if_client_disabled(analyzer: MatchingDocstringsAnalyzer) -> None:
    """
    Automatically skip tests in this file if the AI client is disabled.
    """
    if not analyzer.client:
        pytest.skip("AI client disabled - skipping test")


def test_analyze_consistent_docstrings_pass(analyzer: MatchingDocstringsAnalyzer, pypi_package_json: MagicMock) -> None:
    """Test the analyzer passes when docstrings are consistent with the code."""
    pypi_package_json.download_sourcecode.return_value = True
    pypi_package_json.iter_sourcecode.return_value = [("test.py", b"def func():\n    '''docstring'''\n    pass")]

    mock_result = Result(decision="consistent", reason="The code is consistent with the docstring.")

    with patch.object(analyzer.client, "invoke", return_value=mock_result) as mock_invoke:
        result, info = analyzer.analyze(pypi_package_json)
        assert result == HeuristicResult.PASS
        assert not info
        mock_invoke.assert_called_once()


def test_analyze_inconsistent_docstrings_fail(
    analyzer: MatchingDocstringsAnalyzer, pypi_package_json: MagicMock
) -> None:
    """Test the analyzer fails when docstrings are inconsistent with the code."""
    pypi_package_json.download_sourcecode.return_value = True
    pypi_package_json.iter_sourcecode.return_value = [
        ("test.py", b"def func():\n    '''docstring'''\n    print('hello')")
    ]

    mock_result = Result(
        decision="inconsistent",
        reason="The docstring does not mention the print statement.",
        inconsistent_code_part="print('hello')",
    )

    with patch.object(analyzer.client, "invoke", return_value=mock_result):
        result, info = analyzer.analyze(pypi_package_json)
        assert result == HeuristicResult.FAIL
        assert info["file"] == "test.py"
        assert info["reason"] == "The docstring does not mention the print statement."
        assert info["inconsistent part"] == "print('hello')"


def test_analyze_no_source_code_skip(analyzer: MatchingDocstringsAnalyzer, pypi_package_json: MagicMock) -> None:
    """Test the analyzer skips if the source code cannot be downloaded."""
    pypi_package_json.download_sourcecode.return_value = False
    with patch.object(analyzer.client, "invoke") as mock_invoke:
        result, info = analyzer.analyze(pypi_package_json)
        assert result == HeuristicResult.SKIP
        assert not info
        mock_invoke.assert_not_called()


def test_analyze_no_python_files_pass(analyzer: MatchingDocstringsAnalyzer, pypi_package_json: MagicMock) -> None:
    """Test the analyzer passes if there are no Python files in the source code."""
    pypi_package_json.download_sourcecode.return_value = True
    pypi_package_json.iter_sourcecode.return_value = [("README.md", b"This is a test package.")]
    with patch.object(analyzer.client, "invoke") as mock_invoke:
        result, info = analyzer.analyze(pypi_package_json)
        assert result == HeuristicResult.PASS
        assert not info
        mock_invoke.assert_not_called()


def test_analyze_llm_invocation_error_pass(analyzer: MatchingDocstringsAnalyzer, pypi_package_json: MagicMock) -> None:
    """Test the analyzer passes if the LLM invocation returns None (e.g., on API error)."""
    pypi_package_json.download_sourcecode.return_value = True
    pypi_package_json.iter_sourcecode.return_value = [("test.py", b"def func():\n    pass")]

    with patch.object(analyzer.client, "invoke", return_value=None):
        result, info = analyzer.analyze(pypi_package_json)
        assert result == HeuristicResult.PASS
        assert not info
