# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""Tests for the TypeStubFileAnalyzer heuristic."""

from unittest.mock import MagicMock, patch

import pytest

from macaron.errors import SourceCodeError
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult
from macaron.malware_analyzer.pypi_heuristics.metadata.type_stub_file import TypeStubFileAnalyzer


@pytest.fixture(name="analyzer")
def analyzer_() -> TypeStubFileAnalyzer:
    """Pytest fixture to create a TypeStubFileAnalyzer instance."""
    return TypeStubFileAnalyzer()


def test_analyze_sufficient_files_pass(analyzer: TypeStubFileAnalyzer, pypi_package_json: MagicMock) -> None:
    """Test the analyzer passes when the package has sufficient files."""
    pypi_package_json.download_sourcecode.return_value = True
    pypi_package_json.package_sourcecode_path = "/fake/path"
    with patch("os.walk") as mock_walk:
        mock_walk.return_value = [("root", [], [f"file{i}.pyi" for i in range(60)])]
        result, _ = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.PASS
    pypi_package_json.download_sourcecode.assert_called_once()


def test_analyze_exactly_threshold_files_pass(analyzer: TypeStubFileAnalyzer, pypi_package_json: MagicMock) -> None:
    """Test the analyzer passes when the package has exactly the threshold number of files."""
    pypi_package_json.download_sourcecode.return_value = True
    pypi_package_json.package_sourcecode_path = "/fake/path"
    with patch("os.walk") as mock_walk:
        mock_walk.return_value = [("root", [], [f"file{i}.pyi" for i in range(10)])]
        result, _ = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.PASS


def test_analyze_insufficient_files_fail(analyzer: TypeStubFileAnalyzer, pypi_package_json: MagicMock) -> None:
    """Test the analyzer fails when the package has insufficient files."""
    pypi_package_json.download_sourcecode.return_value = True
    pypi_package_json.package_sourcecode_path = "/fake/path"
    with patch("os.walk") as mock_walk:
        mock_walk.return_value = [("root", [], ["file1.pyi"])]
        result, _ = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL


def test_analyze_no_files_fail(analyzer: TypeStubFileAnalyzer, pypi_package_json: MagicMock) -> None:
    """Test the analyzer fails when the package has no files."""
    pypi_package_json.download_sourcecode.return_value = True
    pypi_package_json.package_sourcecode_path = "/fake/path"
    with patch("os.walk") as mock_walk:
        mock_walk.return_value = [("root", [], [])]
        result, _ = analyzer.analyze(pypi_package_json)

    assert result == HeuristicResult.FAIL


def test_analyze_download_failed_raises_error(analyzer: TypeStubFileAnalyzer, pypi_package_json: MagicMock) -> None:
    """Test the analyzer raises SourceCodeError when source code download fails."""
    pypi_package_json.download_sourcecode.return_value = False

    with pytest.raises(SourceCodeError) as exc_info:
        analyzer.analyze(pypi_package_json)

    assert "No source code files have been downloaded" in str(exc_info.value)
    pypi_package_json.download_sourcecode.assert_called_once()


@pytest.mark.parametrize(
    ("file_count", "expected_result"),
    [
        (0, HeuristicResult.FAIL),
        (1, HeuristicResult.FAIL),
        (2, HeuristicResult.FAIL),
        (12, HeuristicResult.PASS),
        (15, HeuristicResult.PASS),
    ],
)
def test_analyze_file_counts(
    analyzer: TypeStubFileAnalyzer,
    pypi_package_json: MagicMock,
    file_count: int,
    expected_result: HeuristicResult,
    monkeypatch: pytest.MonkeyPatch,
) -> None:
    """Test the analyzer with various file counts."""
    pypi_package_json.download_sourcecode.return_value = True
    pypi_package_json.package_sourcecode_path = "/fake/path"
    files = [f"file{i}.pyi" for i in range(file_count)]
    mock_walk = MagicMock(return_value=[("root", [], files)])
    monkeypatch.setattr("os.walk", mock_walk)

    result, _ = analyzer.analyze(pypi_package_json)

    assert result == expected_result
