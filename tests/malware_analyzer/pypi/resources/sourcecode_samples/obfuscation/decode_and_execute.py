# Copyright (c) 2025 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""
Running this code will not produce any malicious behavior, but code isolation measures are
in place for safety.
"""

import sys

# ensure no symbols are exported so this code cannot accidentally be used
__all__ = []
sys.exit()

def test_function():
    """
    All code to be tested will be defined inside this function, so it is all local to it. This is
    to isolate the code to be tested, as it exists to replicate the patterns present in malware
    samples.
    """
    sys.exit()

    # NOTE: since these are flows, all will go in subfunctions that they are supposed to be in so the detections
    # can be sections out.

    # marshal encryption from pyobfuscate.com/marshal-encrypt, script is just print("Hello world!")
    def marshal_flow():
        from marshal import loads
        bytecode = loads(b'\xe3\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00@\x00\x00\x00s\x0c\x00\x00\x00e\x00d\x00\x83\x01\x01\x00d\x01S\x00)\x02z\x0cHello world!N)\x01\xda\x05print\xa9\x00r\x02\x00\x00\x00r\x02\x00\x00\x00\xfa\x08<string>\xda\x08<module>\x01\x00\x00\x00\xf3\x00\x00\x00\x00')
        exec(bytecode)

    def marshal_inline_flow():
        exec(__import__('marshal').loads(b'\xe3\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00@\x00\x00\x00s\x0c\x00\x00\x00e\x00d\x00\x83\x01\x01\x00d\x01S\x00)\x02z\x0cHello world!N)\x01\xda\x05print\xa9\x00r\x02\x00\x00\x00r\x02\x00\x00\x00\xfa\x08<string>\xda\x08<module>\x01\x00\x00\x00\xf3\x00\x00\x00\x00'))

    def bytes_eval_to_soc_bind():
        import socket
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as soc:
            soc.bind(__import__('builtins').eval(b'("127.0.0.1", 0)'.decode()))

    def map_b64_to_request():
        import requests as req

        # decodes to GET
        method = __import__('base64').b64decode(b'R0VU')
        # just maps to a random fake link https://www.print-hello-world-sample.com/print/hello/world!
        link = ''.join(map(chr, [104, 116, 116, 112, 115, 58, 47, 47, 119, 119, 119, 46, 112, 114, 105, 110, 116, 45, 104, 101, 108, 108, 111, 45, 119, 111, 114, 108, 100, 45, 115, 97, 109, 112, 108, 101, 46, 99, 111, 109, 47, 112, 114, 105, 110, 116, 47, 104, 101, 108, 108, 111, 47, 119, 111, 114, 108, 100, 33]))
        _ = req.Request(method, link)

    def zlib_ast_subprocess():
        import subprocess
        import zlib as zeeee
        from ast import literal_eval

        # just decodes to ["echo", "Hello world!"]
        subprocess.Popen(literal_eval(zeeee.decompress(b'x\x9c\x8bVOM\xce\xc8W\xd7QP\xf7H\xcd\xc9\xc9W(\xcf/\xcaIQT\x8f\x05\x00]\xa0\x07\x9d').decode()))

    def propagation_to_write():
        import os as e

        # symbol propagations should detect assign of os as e to o and bytes to b and still trigger
        o = e
        b = bytes
        # just decodes to "Hello world!"
        contents = b.fromhex("48656C6C6F20776F726C6421")
        # just decodes to "some_path"
        file = o.open(''.join(chr(c) for c in [115, 111, 109, 101, 95, 112, 97, 116, 104]), o.O_RDWR)
        o.pwritev(file, contents, 0)
