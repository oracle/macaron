# Copyright (c) 2024 - 2024, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""Tests for heuristic detecting malicious metadata from PyPI"""

from unittest.mock import MagicMock, Mock, patch

from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult
from macaron.malware_analyzer.pypi_heuristics.metadata.unreachable_project_links import UnreachableProjectLinksAnalyzer
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIRegistry


@patch("requests.head")
def test_analyze_with_all_reachable_links(mock_head: Mock) -> None:
    """Test for all links are reachable"""
    # Setup.
    package = "requests"
    mock_api_client = MagicMock(spec=PyPIRegistry(package))
    project_links: dict = {
        "Documentation": "https://requests.readthedocs.io",
        "Homepage": "https://requests.readthedocs.io",
        "Source": "https://github.com/psf/requests",
    }

    mock_api_client.get_project_links.return_value = project_links
    expected_result: tuple[HeuristicResult, dict] = (HeuristicResult.PASS, {})

    mock_response = MagicMock()
    mock_response.status_code = 200
    mock_head.return_value = mock_response
    analyzer = UnreachableProjectLinksAnalyzer()

    # Execute.
    result: tuple[HeuristicResult, dict] = analyzer.analyze(api_client=mock_api_client)

    # Verify.
    assert result == expected_result


@patch("requests.head")
def test_analyze_with_all_unreachable_links(mock_head: Mock) -> None:
    """Test for all project links are unreachable"""
    # Setup.
    package = "requests5"
    project_links: dict = {"Homepage": "https://github.com/jiangfubang/fast_requests"}
    mock_api_client = MagicMock(spec=PyPIRegistry(package))
    mock_api_client.get_project_links.return_value = project_links
    expected_result: tuple[HeuristicResult, dict] = (HeuristicResult.FAIL, {})

    analyzer = UnreachableProjectLinksAnalyzer()
    mock_response = MagicMock()
    mock_response.status_code = 404
    mock_head.return_value = mock_response

    # Execute.
    result: tuple[HeuristicResult, dict] = analyzer.analyze(api_client=mock_api_client)

    # Verify.
    assert result == expected_result


def test_analyze_with_no_project_links() -> None:
    """Test for the metadata missing"""
    # TODO Package with missing metadata is not available now
    # Setup.
    package = "example" * 5  # Not a package on PyPI.
    mock_api_client = MagicMock(spec=PyPIRegistry(package))
    mock_api_client.get_project_links.return_value = None
    analyzer = UnreachableProjectLinksAnalyzer()
    expected_result: tuple[HeuristicResult, dict] = (HeuristicResult.SKIP, {})

    # Execute.
    result: tuple[HeuristicResult, dict] = analyzer.analyze(api_client=mock_api_client)

    # Verify.
    assert result == expected_result


@patch("requests.head")
def test_analyze_with_mixed_links(mock_head: Mock) -> None:
    """Test for the situation when the links are partially accessible"""
    # Setup.
    package = "requests"
    project_links: dict = {
        "Documentation": "https://requests.readthedocs.io",
        "Homepage": "https://requests.readthedocs.io",
        "Source": "https://badurl.com",
    }
    mock_api_client = MagicMock(spec=PyPIRegistry(package))
    mock_api_client.get_project_links.return_value = project_links
    expected_result: tuple[HeuristicResult, dict] = (HeuristicResult.PASS, {})

    # Mock responses for each URL.
    def side_effect(url: str, *args: tuple, **kwargs: dict) -> Mock:  # pylint: disable=W0613
        mock_response = MagicMock()
        if url == "http://badurl.com":
            mock_response.status_code = 404
        else:
            mock_response.status_code = 200
        return mock_response

    mock_head.side_effect = side_effect
    analyzer = UnreachableProjectLinksAnalyzer()

    # Execute.
    result: tuple[HeuristicResult, dict] = analyzer.analyze(api_client=mock_api_client)

    # Verify.
    assert result == expected_result
