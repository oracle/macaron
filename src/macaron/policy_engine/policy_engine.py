# Copyright (c) 2023 - 2023, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This module handles invoking the souffle policy engine on a database."""

import logging
import os
import sys

from sqlalchemy import MetaData, create_engine, select

from macaron import __version__ as mcn_version
from macaron.database.table_definitions import AnalysisTable
from macaron.policy_engine.souffle import SouffleError, SouffleWrapper
from macaron.policy_engine.souffle_code_generator import (
    SouffleProgram,
    get_souffle_import_prelude,
    project_table_to_key,
    project_with_fk_join,
)

logger: logging.Logger = logging.getLogger(__name__)


def get_generated(database_path: os.PathLike | str) -> SouffleProgram:
    """Get generated souffle code from database specified by configuration.

    Parameters
    ----------
    database_path: os.PathLike | str
        The path to the database to generate imports and prelude for

    Returns
    -------
    SouffleProgram
        A program containing the declarations and relations for the schema of this database

    See Also
    --------
    souffle_code_generator.py
    """
    if not os.path.isfile(database_path):
        logger.error("Unable to open database %s", database_path)
        sys.exit(1)

    metadata = MetaData()
    engine = create_engine(f"sqlite:///{database_path}", echo=False)
    metadata.reflect(engine)

    prelude = get_souffle_import_prelude(os.path.abspath(database_path), metadata)

    for table_name in metadata.tables.keys():
        table = metadata.tables[table_name]
        if table_name[0] == "_":
            prelude.update(project_table_to_key(f"{table_name[1:]}_attribute", table))
            prelude.update(project_with_fk_join(table))

    return prelude


def copy_prelude(database_path: os.PathLike | str, sfl: SouffleWrapper, prelude: SouffleProgram | None = None) -> None:
    """
    Generate and copy the prelude into the souffle instance's include directory.

    Parameters
    ----------
    database_path: os.PathLike | str
        The path to the database the facts will be imported from
    sfl: SouffleWrapper
        The souffle execution context object
    prelude: SouffleProgram | None
        Optional, the prelude to use for the souffle program, if none is given the default prelude is generated from
        the database at database_path.
    """
    if prelude is None:
        prelude = get_generated(database_path)
    sfl.copy_to_includes("import_data.dl", str(prelude))

    folder = os.path.join(os.path.dirname(__file__), "prelude")
    for file_name in os.listdir(folder):
        full_file_name = os.path.join(folder, file_name)
        if not os.path.isfile(full_file_name):
            continue
        with open(full_file_name, encoding="utf-8") as file:
            text = file.read()
            sfl.copy_to_includes(file_name, text)


def run_souffle(database_path: str, policy_file: str) -> dict:
    """Invoke souffle and report result.

    Parameters
    ----------
    database_path: str
        The path to the database to evaluate the policy on
    policy_file: str
        The path to the policy file to evaluate

    Returns
    -------
    dict
        A dictionary containing all the relations returned by souffle mapping relation_name to the list of rows.
    """
    with SouffleWrapper() as sfl:
        copy_prelude(database_path, sfl)
        with open(policy_file, encoding="utf-8") as file:
            text = file.read()

        try:
            res = sfl.interpret_text(text)
        except SouffleError as error:
            logger.error("COMMAND: %s", error.command)
            logger.error("ERROR: %s", error.message)
            sys.exit(1)

        return res


def _check_version(database_path: str) -> None:
    """Verify that database was generated by a compatible version.

    TODO: improve this check and allow version ranges. Perhaps check
    for major version updates?

    Parameters
    ----------
    database_path: str
        The path to the macaron database
    """
    engine = create_engine(f"sqlite:///{database_path}", echo=False)

    with engine.connect() as conn:
        versions = conn.execute(
            select(AnalysisTable.macaron_version).where(AnalysisTable.macaron_version != mcn_version)
        ).scalar()
        if versions is not None:
            logger.error("Database generated with unsupported versions (%s).", versions)
            logger.error("Only databases generated by Macaron version %s are supported.", mcn_version)
            sys.exit(os.EX_DATAERR)


def run_policy_engine(database_path: str, show_prelude: bool, policy_file: str) -> dict:
    """Evaluate a policy based on configuration and exit.

    Parameters
    ----------
    database_path: str
        The SQLite database file to evaluate the policy against
    show_prelude: bool
        Just show the policy prelude and exit.
    policy_file: str
        The policy file to evaluate

    Returns
    -------
    dict
        The policy engine result.
    """
    if show_prelude:
        prelude = get_generated(database_path)
        logger.info("\n%s", prelude)
        return {}

    # TODO: uncomment the following line when the check is improved.
    # _check_version(database_path)

    res = run_souffle(database_path, policy_file)

    output = []
    for key, values in res.items():
        output.append(str(key))
        for value in values:
            output.append(f"    {value}")

    logger.info("Policy results:\n%s", "\n".join(output))

    return res
