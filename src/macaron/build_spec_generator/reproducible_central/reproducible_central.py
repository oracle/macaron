# Copyright (c) 2025 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This module contains the logic to generate a build spec in Reproducible Central format."""

import logging
import pprint
import shlex
from collections.abc import Mapping, Sequence
from enum import Enum
from importlib import metadata as importlib_metadata
from pprint import pformat

import sqlalchemy.orm
from packageurl import PackageURL

from macaron.build_spec_generator.build_command_patcher import PatchCommandBuildTool, PatchValueType, patch_commands
from macaron.build_spec_generator.jdk_finder import find_jdk_version_from_central_maven_repo
from macaron.build_spec_generator.jdk_version_normalizer import normalize_jdk_version
from macaron.build_spec_generator.macaron_db_extractor import (
    GenericBuildCommandInfo,
    lookup_any_build_command,
    lookup_build_tools_check,
    lookup_latest_component,
)
from macaron.errors import QueryMacaronDatabaseError
from macaron.slsa_analyzer.checks.build_tool_check import BuildToolFacts

logger: logging.Logger = logging.getLogger(__name__)

# We use a subset of available config options from
# https://github.com/jvm-repo-rebuild/reproducible-central/blob/master/doc/BUILDSPEC.md
# An example:
#   https://github.com/jvm-repo-rebuild/reproducible-central/blob/master/content/com/google/guava/guava-32.0.0-android.buildspec
# About this template
#   - Because the Reproducible-Central build spec is a bash script by itself, we can use
#     Bash comment syntax.
#   - We only work with git repository and its commit hash. Therefore `gitRepo` and `gitTag` are used only.
#     Even though it's called gitTag, a commit hash would work.
#     https://github.com/jvm-repo-rebuild/reproducible-central/blob/46de9b405cb30ff94effe0ba47c1ebecc5a1c17e/bin/includes/fetchSource.sh#L59C1-L59C72
STRING_TEMPLATE = """# Copyright (c) 2025, Oracle and/or its affiliates.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.
# Generated by Macaron version {macaron_version}

groupId={group_id}
artifactId={artifact_id}
version={version}

gitRepo={git_repo}

gitTag={git_tag}

tool={tool}
jdk={jdk}

newline={newline}

command="{command}"

buildinfo={buildinfo}
"""


class _MacaronBuildToolName(str, Enum):
    """Represent the name of a build tool that Macaron stores in the database.

    These doesn't cover all build tools that Macaron support, and ONLY include the ones that we
    support generating Reproducible Central Buildspec for.
    """

    MAVEN = "maven"
    GRADLE = "gradle"


class ReproducibleCentralBuildTool(str, Enum):
    """Represent the name of the build tool used in the Reproducible Central's Buildspec.

    https://github.com/jvm-repo-rebuild/reproducible-central/blob/master/doc/BUILDSPEC.md
    """

    MAVEN = "mvn"
    GRADLE = "gradle"
    SBT = "sbt"


def format_build_command_infos(build_command_infos: list[GenericBuildCommandInfo]) -> str:
    """Return the prettified str format for a list of `GenericBuildCommandInfo` instances.

    Parameters
    ----------
    build_command_infos: GenericBuildCommandInfo
        A list of ``GenericBuildCommandInfo`` instances.

    Returns
    -------
    str
        The prettified output.
    """
    pretty_formatted_ouput = [pprint.pformat(build_command_info) for build_command_info in build_command_infos]
    return "\n".join(pretty_formatted_ouput)


def remove_shell_quote(cmd: list[str]) -> list[str]:
    """Remove shell quotes from a shell command.

    Parameters
    ----------
    cmd: list[str]
        The shell command as list of string.

    Returns
    -------
    list[str]
        The shell command with all quote removed.

    Examples
    --------
    >>> cmd = "mvn -f fit/core-reference/pom.xml verify '-Dit.test=RESTITCase' '-Dmodernizer.skip=true' '-Drat.skip=true'"
    >>> remove_shell_quote(cmd.split())
    ['mvn', '-f', 'fit/core-reference/pom.xml', 'verify', '-Dit.test=RESTITCase', '-Dmodernizer.skip=true', '-Drat.skip=true']
    """
    return shlex.split(" ".join(cmd))


def get_rc_build_command(cmds_sequence: list[list[str]]) -> str:
    """Return a single command as string to be used in RC buildspec from a sequence of commands.

    The build commands in the sequence will be ``&&`` together, because RC's build spec
    is a shell script.

    Parameters
    ----------
    cmds_sequence: list[list[str]]
        The sequence of build commands.

    Returns
    -------
    str
        A bash command to be used in RC's command field.
    """
    removed_shell_quote = [" ".join(remove_shell_quote(cmds)) for cmds in cmds_sequence]
    result = " && ".join(removed_shell_quote)
    return result


def get_rc_default_build_command(
    rc_build_tool_name: ReproducibleCentralBuildTool,
) -> list[str] | None:
    """Return a default build command for a type of Reproducible Central build tool type.

    Parameters
    ----------
    rc_build_tool_name: ReproducibleCentralBuildTool
        The type of build tool to get the default build command.

    Returns
    -------
    list[str] | None
        The build command as a list of strings or None if we cannot get one for this tool.
    """
    default_build_command = None

    match rc_build_tool_name:
        case ReproducibleCentralBuildTool.MAVEN:
            default_build_command = "mvn clean package".split()
        case ReproducibleCentralBuildTool.GRADLE:
            default_build_command = "./gradlew clean assemble publishToMavenLocal".split()
        case _:
            pass

    if not default_build_command:
        logger.critical(
            "There is no default build command available for RC build tool %s.",
            rc_build_tool_name,
        )
        return None

    return default_build_command


def _get_macaron_build_tool_name(build_tool_facts: Sequence[BuildToolFacts]) -> _MacaronBuildToolName | None:
    """Return the build tool name reported by Macaron from the database."""
    for fact in build_tool_facts:
        if fact.language in {"java"}:
            try:
                macaron_build_tool_name = _MacaronBuildToolName(fact.build_tool_name)
            except ValueError:
                continue

            # TODO: What happen if we report multiple build tools in the database.
            return macaron_build_tool_name

    return None


def _get_rc_build_tool_name_from_build_facts(
    build_tool_facts: Sequence[BuildToolFacts],
) -> ReproducibleCentralBuildTool | None:
    """Return the build tool name to be put into the RC buildspec from a sequence of BuildToolFacts instances."""
    macaron_build_tool_name = _get_macaron_build_tool_name(build_tool_facts)
    if not macaron_build_tool_name:
        logger.error(
            "No supported build tool are found. Expect %s",
            [build_tool.value for build_tool in _MacaronBuildToolName],
        )
        return None

    match macaron_build_tool_name:
        case _MacaronBuildToolName.MAVEN:
            return ReproducibleCentralBuildTool.MAVEN
        case _MacaronBuildToolName.GRADLE:
            return ReproducibleCentralBuildTool.GRADLE


def get_rc_build_tool_name(
    component_id: int,
    session: sqlalchemy.orm.Session,
) -> ReproducibleCentralBuildTool | None:
    """Return the ``ReproducibleCentralBuildTool`` instance corresponding to the build tool of the component.

    Parameters
    ----------
    component_id: int
        The id of the component we are finding build command for.
    session: sqlalchemy.orm.Session
        The SQLAlchemy Session opened for the database to extract build information.

    Returns
    -------
    ReproducibleCentralBuildTool | None
        The ``ReproducibleCentralBuildTool`` instance for this component.
    """
    try:
        build_tool_facts = lookup_build_tools_check(
            component_id=component_id,
            session=session,
        )
    except QueryMacaronDatabaseError as lookup_build_tools_error:
        logger.error(
            "Unexpected result from querying build tools for component id %s. Error: %s",
            component_id,
            lookup_build_tools_error,
        )
        return None
    if not build_tool_facts:
        logger.error(
            "Cannot find any build tool for component id %s in the database.",
            component_id,
        )
        return None
    logger.info(
        "Build tools discovered from the %s table: %s",
        BuildToolFacts.__tablename__,
        [(fact.build_tool_name, fact.language) for fact in build_tool_facts],
    )

    return _get_rc_build_tool_name_from_build_facts(build_tool_facts)


def get_lookup_build_command_info(
    component_id: int,
    session: sqlalchemy.orm.Session,
) -> GenericBuildCommandInfo | None:
    """Return the highest confidence build command information from the database for a component.

    The build command is found by looking up CheckFacts for build-related checks.

    Parameters
    ----------
    component_id: int
        The id of the component we are finding build command for.
    session: sqlalchemy.orm.Session
        The SQLAlchemy Session opened for the database to extract build information.

    Returns
    -------
    GenericBuildCommandInfo | None
        The GenericBuildCommandInfo object for the highest confidence build command or None if there was
        an error, or no build command is found from the database.
    """
    try:
        lookup_build_command_infos = lookup_any_build_command(component_id, session)
    except QueryMacaronDatabaseError as lookup_build_command_error:
        logger.error(
            "Unexpected result from querying all build command information for component id %s. Error: %s",
            component_id,
            lookup_build_command_error,
        )
        return None
    logger.debug(
        "Build command information discovered\n%s",
        format_build_command_infos(lookup_build_command_infos),
    )

    return lookup_build_command_infos[0] if lookup_build_command_infos else None


def get_lookup_build_command_jdk(
    build_command_info: GenericBuildCommandInfo,
) -> str | None:
    """Return the jdk version from a GenericBuildCommandInfo object."""
    if build_command_info.language_versions:
        # There isn't a concrete reason why we select the last element.
        # We just use this at this point because we haven't looked into
        # a better way to select the jdk version obtained from the database.
        return build_command_info.language_versions.pop()

    return None


def gen_reproducible_central_build_spec(
    purl: PackageURL,
    session: sqlalchemy.orm.Session,
    patches: Mapping[
        PatchCommandBuildTool,
        Mapping[str, PatchValueType | None],
    ],
) -> str | None:
    """Return the content of a Reproducible Central Buildspec File.

    The Reproducible Central Buildspec File Format can be found here:
    https://github.com/jvm-repo-rebuild/reproducible-central/blob/e1708dd8dde3cdbe66b0cec9948812b601e90ba6/doc/BUILDSPEC.md#format

    Parameters
    ----------
    purl: PackageURL
        The PackageURL to generate build spec for.
    session: sqlalchemy.orm.Session
        The SQLAlchemy Session opened for the database to extract build information.
    patches: Mapping[PatchCommandBuildTool, Mapping[str, PatchValueType | None]]
        The patches to apply to the build commands in ``build_info`` before being populated in
        the output Buildspec.

    Returns
    -------
    str | None
        The content of the Buildspec as string or None if there is an error.
        The errors that can happen are: 1. The input PURL is invalid, 2. There is no supported build tool
        for this PURL, 3. Failed to patch the build commands using the provided ``patches``, 4. The database from
        ``session`` doesn't contain enough information.
    """
    logger.debug(
        "Generating build spec for %s with command patches:\n%s",
        purl,
        pformat(patches),
    )

    # Getting groupid, artifactid and version from PURL.
    group = purl.namespace
    artifact = purl.name
    version = purl.version
    if group is None or version is None:
        logger.error("Missing group and/or version for purl %s.", purl.to_string())
        return None

    try:
        latest_component = lookup_latest_component(
            purl=purl,
            session=session,
        )
    except QueryMacaronDatabaseError as lookup_component_error:
        logger.error(
            "Unexpected result from querying latest component for %s. Error: %s",
            purl.to_string(),
            lookup_component_error,
        )
        return None
    if not latest_component:
        logger.error(
            "Cannot find an analysis result for PackageURL %s in the database. "
            + "Please check if an analysis for it exists in the database.",
            purl.to_string(),
        )
        return None

    latest_component_repository = latest_component.repository
    if not latest_component_repository:
        logger.error(
            "Cannot find any repository information for %s in the database.",
            purl.to_string(),
        )
        return None
    logger.info(
        "Repository information for purl %s: url %s, commit %s",
        purl,
        latest_component_repository.remote_path,
        latest_component_repository.commit_sha,
    )

    # Getting the RC build tool name from the build tool check facts.
    rc_build_tool_name = get_rc_build_tool_name(
        component_id=latest_component.id,
        session=session,
    )
    if not rc_build_tool_name:
        return None

    # We always attempt to get the JDK version from maven central JAR for this GAV artifact.
    jdk_from_jar = find_jdk_version_from_central_maven_repo(
        group_id=group,
        artifact_id=artifact,
        version=version,
    )
    logger.info(
        "Attempted to find JDK from Maven Central JAR. Result: %s",
        jdk_from_jar or "Cannot find any.",
    )

    # Obtain the highest confidence build command info from the database.
    lookup_build_command_info = get_lookup_build_command_info(
        component_id=latest_component.id,
        session=session,
    )
    logger.info(
        "Attempted to find build command from the database. Result: %s",
        lookup_build_command_info or "Cannot find any.",
    )
    lookup_build_command_jdk = (
        get_lookup_build_command_jdk(
            lookup_build_command_info,
        )
        if lookup_build_command_info
        else None
    )

    # Select jdk from jar from different source.
    # The default JDK version is 8.
    selected_jdk_version = jdk_from_jar or lookup_build_command_jdk or "8"
    major_jdk_version = normalize_jdk_version(selected_jdk_version)
    if not major_jdk_version:
        logger.error("Failed to obtain the major version of %s", selected_jdk_version)
        return None

    # Select build commands from lookup or use a default one.
    selected_build_command = (
        lookup_build_command_info.command
        if lookup_build_command_info
        else get_rc_default_build_command(
            rc_build_tool_name,
        )
    )
    if not selected_build_command:
        logger.error("Failed to get a build command for %s.", purl.to_string())
        return None

    patched_build_commands = patch_commands(
        cmds_sequence=[selected_build_command],
        patches=patches,
    )
    if not patched_build_commands:
        logger.error(
            "Failed to patch command sequences %s.",
            [selected_build_command],
        )
        return None

    template_format_values: dict[str, str] = {
        "macaron_version": importlib_metadata.version("macaron"),
        "group_id": group,
        "artifact_id": artifact,
        "version": version,
        "git_repo": latest_component_repository.remote_path,
        "git_tag": latest_component_repository.commit_sha,
        "tool": rc_build_tool_name.value,
        "newline": "lf",
        "buildinfo": f"target/{artifact}-{version}.buildinfo",
        "jdk": major_jdk_version,
        "command": get_rc_build_command(patched_build_commands),
    }

    return STRING_TEMPLATE.format_map(template_format_values)
