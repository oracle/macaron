# Copyright (c) 2025 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This module contains the logic to generate a build spec in Reproducible Central format."""

import logging
import shlex
from collections.abc import Mapping, Sequence
from enum import Enum
from importlib import metadata as importlib_metadata
from pprint import pformat

import sqlalchemy.orm
from packageurl import PackageURL

from macaron.build_spec_generator.build_command_patcher import PatchCommandBuildTool, PatchValueType, patch_commands
from macaron.build_spec_generator.jdk_finder import find_jdk_version_from_central_maven_repo
from macaron.build_spec_generator.jdk_version_normalizer import normalize_jdk_version
from macaron.build_spec_generator.reproducible_central.rc_build_info import (
    RcInternalBuildInfo,
    get_rc_internal_build_info,
)
from macaron.slsa_analyzer.checks.build_tool_check import BuildToolFacts

logger: logging.Logger = logging.getLogger(__name__)

# We use a subset of available config options from
# https://github.com/jvm-repo-rebuild/reproducible-central/blob/master/doc/BUILDSPEC.md
# An example:
#   https://github.com/jvm-repo-rebuild/reproducible-central/blob/master/content/com/google/guava/guava-32.0.0-android.buildspec
# About this template
#   - Because the Reproducible-Central build spec is a bash script by itself, we can use
#     Bash comment syntax.
#   - We only work with git repository and its commit hash. Therefore `gitRepo` and `gitTag` are used only.
#     Even though it's called gitTag, a commit hash would work.
#     https://github.com/jvm-repo-rebuild/reproducible-central/blob/46de9b405cb30ff94effe0ba47c1ebecc5a1c17e/bin/includes/fetchSource.sh#L59C1-L59C72
STRING_TEMPLATE = """# Copyright (c) 2025, Oracle and/or its affiliates.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.
# Generated by Macaron version {macaron_version}

{extra_comment}

groupId={group_id}
artifactId={artifact_id}
version={version}

gitRepo={git_repo}

gitTag={git_tag}

tool={tool}
jdk={jdk}

newline={newline}

command="{command}"

buildinfo={buildinfo}
"""


class _MacaronBuildToolName(str, Enum):
    """Represent the name of a build tool that Macaron stores in the database.

    These doesn't cover all build tools that Macaron support, and ONLY include the ones that we
    support generating Reproducible Central Buildspec for.
    """

    MAVEN = "maven"
    GRADLE = "gradle"


class _ReproducibleCentralBuildToolName(str, Enum):
    """Represent the name of the build tool used in the Reproducible Central's Buildspec.

    https://github.com/jvm-repo-rebuild/reproducible-central/blob/master/doc/BUILDSPEC.md
    """

    MAVEN = "mvn"
    GRADLE = "gradle"
    SBT = "sbt"


def remove_shell_quote(cmd: list[str]) -> list[str]:
    """Remove shell quotes from a shell command.

    Parameters
    ----------
    cmd: list[str]
        The shell command as list of string.

    Returns
    -------
    list[str]
        The shell command with all quote removed.

    Examples
    --------
    >>> cmd = "mvn -f fit/core-reference/pom.xml verify '-Dit.test=RESTITCase' '-Dmodernizer.skip=true' '-Drat.skip=true'"
    >>> remove_shell_quote(cmd.split())
    ['mvn', '-f', 'fit/core-reference/pom.xml', 'verify', '-Dit.test=RESTITCase', '-Dmodernizer.skip=true', '-Drat.skip=true']
    """
    return shlex.split(" ".join(cmd))


def _get_extra_comments(comments: list[str]) -> str:
    """Generate the shell comments for adding additional information into the RC-build spec."""
    shell_comments = [f"# {comment}" for comment in comments]
    return "\n".join(shell_comments)


def _get_build_command_sequence(cmds_sequence: list[list[str]]) -> str:
    """Return a build command sequence as a string.

    The build commands in the sequence will be && together, because RC's build spec
    is a shell script.
    """
    removed_shell_quote = [" ".join(remove_shell_quote(cmds)) for cmds in cmds_sequence]
    result = " && ".join(removed_shell_quote)
    return result


def _get_default_build_command_sequence(
    macaron_build_tool_name: _MacaronBuildToolName,
    patches: Mapping[
        PatchCommandBuildTool,
        Mapping[str, PatchValueType | None],
    ],
) -> list[list[str]] | None:
    """Return a default build command sequence for the corresponding build tool name discovered by Macaron."""
    default_build_command = None
    if macaron_build_tool_name == _MacaronBuildToolName.MAVEN:
        default_build_command = "mvn clean package"

    if macaron_build_tool_name == _MacaronBuildToolName.GRADLE:
        default_build_command = "./gradlew clean assemble publishToMavenLocal"

    if not default_build_command:
        logger.critical(
            "The default build command %s is not supported for getting default build command.",
            macaron_build_tool_name,
        )
        return None

    patched_build_commands = patch_commands(
        cmds_sequence=[default_build_command.split()],
        patches=patches,
    )

    if not patched_build_commands:
        logger.error(
            "Failed to patch default build command %s.",
            default_build_command,
        )
        return None

    return patched_build_commands


def _get_macaron_build_tool_name(build_tool_facts: Sequence[BuildToolFacts]) -> _MacaronBuildToolName | None:
    """Return the build tool name reported by Macaron from the database."""
    for fact in build_tool_facts:
        if fact.language in {"java"}:
            try:
                macaron_build_tool_name = _MacaronBuildToolName(fact.build_tool_name)
            except ValueError:
                continue

            # TODO: What happen if we report multiple build tool in the database.
            return macaron_build_tool_name

    return None


def _gen_reproducible_central_build_spec(
    build_info: RcInternalBuildInfo,
    patches: Mapping[
        PatchCommandBuildTool,
        Mapping[str, PatchValueType | None],
    ],
) -> str | None:
    """Return the RC's Buildspec content from a ``RcInternalBuildInfo`` instance.

    This function will perform necessary validation on the data captured within ``build_info`` to make sure
    it has enough information for generating the output BuildSpec.

    This function will use the information available in ``build_info`` to populate the file.
    For example, the GAV coordinate can be obtained from ``build_info.purl``.

    The ``patches`` mapping will be used for patching the build command in the `command` section of the Buildspec
    output.

    The function will return the Buildspec file content as string or None if there is an error.
    """
    extra_comments = []

    purl = build_info.purl
    logger.debug(
        "Generating build spec for %s with command patches:\n%s",
        purl,
        pformat(patches),
    )

    group = purl.namespace
    artifact = purl.name
    version = purl.version
    if group is None or version is None:
        logger.error("Missing group and/or version for purl %s.", purl.to_string())
        return None

    extra_comments.append(f"Input PURL - {purl}")

    macaron_build_tool_name = _get_macaron_build_tool_name(build_info.build_tool_facts)
    if not macaron_build_tool_name:
        logger.error(
            "The PackageURL %s doesn't have any build tool that we support for generating RC buildspec. It has %s.",
            purl.to_string(),
            [(fact.build_tool_name, fact.language) for fact in build_info.build_tool_facts],
        )
        return None

    rc_build_tool_name = None
    if macaron_build_tool_name == _MacaronBuildToolName.MAVEN:
        rc_build_tool_name = _ReproducibleCentralBuildToolName.MAVEN
    elif macaron_build_tool_name == _MacaronBuildToolName.GRADLE:
        rc_build_tool_name = _ReproducibleCentralBuildToolName.GRADLE
    if not rc_build_tool_name:
        logger.critical("%s is not supported to generate RC's buildspec.", macaron_build_tool_name.value)
        return None

    # Set the default build command and jdk version.
    # The default build command depends on the build tool, while the default jdk version
    # is 8.
    final_build_command_seq = _get_default_build_command_sequence(
        macaron_build_tool_name=macaron_build_tool_name,
        patches=patches,
    )
    if not final_build_command_seq:
        logger.critical(
            "Cannot generate a default build command for %s",
            purl,
        )
        return None
    final_jdk_version = "8"
    extra_comments.append(
        f"Initial default JDK version {final_jdk_version} and default build command {final_build_command_seq}."
    )

    if build_info.generic_build_command_facts:
        # The elements are ordered in decreasing confidence score. We pick the highest one.
        build_fact = build_info.generic_build_command_facts[0]
        lookup_build_command = build_fact.command
        extra_comments.append(f"The lookup build command: {lookup_build_command}")

        patched_build_commands = patch_commands(
            cmds_sequence=[lookup_build_command],
            patches=patches,
        )
        if not patched_build_commands:
            logger.error(
                "Failed to patch look up command %s.",
                lookup_build_command,
            )
            return None

        final_build_command_seq = patched_build_commands

        lookup_jdk_vers = build_fact.language_versions
        if lookup_jdk_vers:
            lookup_jdk_ver = lookup_jdk_vers.pop()
            extra_comments.append(f"Jdk version from lookup build command {lookup_jdk_ver}.")
            final_jdk_version = lookup_jdk_ver
        else:
            extra_comments.append("No JDK version found from lookup result.")
            jdk_from_jar = find_jdk_version_from_central_maven_repo(
                group_id=purl.name,
                artifact_id=group,
                version=version,
            )
            if jdk_from_jar:
                extra_comments.append(f"Found JDK version from jar {jdk_from_jar}.")
                final_jdk_version = jdk_from_jar
            else:
                extra_comments.append(f"No JDK version found from jar {jdk_from_jar}.")

    major_jdk_version = normalize_jdk_version(final_jdk_version)
    if not major_jdk_version:
        logger.error("Failed to obtain the major version of %s", final_jdk_version)
        return None

    template_format_values: dict[str, str] = {
        "macaron_version": importlib_metadata.version("macaron"),
        "group_id": group,
        "artifact_id": artifact,
        "version": version,
        "git_repo": build_info.repository.remote_path,
        "git_tag": build_info.repository.commit_sha,
        "tool": rc_build_tool_name.value,
        "newline": "lf",
        "buildinfo": f"target/{artifact}-{version}.buildinfo",
        "extra_comment": _get_extra_comments(extra_comments),
        "jdk": final_jdk_version,
        "command": _get_build_command_sequence(final_build_command_seq),
    }

    return STRING_TEMPLATE.format_map(template_format_values)


def gen_reproducible_central_build_spec(
    purl: PackageURL,
    session: sqlalchemy.orm.Session,
    patches: Mapping[
        PatchCommandBuildTool,
        Mapping[str, PatchValueType | None],
    ],
) -> str | None:
    """Return the content of a Reproducible Central Buildspec File.

    The Reproducible Central Buildspec File Format can be found here:
    https://github.com/jvm-repo-rebuild/reproducible-central/blob/e1708dd8dde3cdbe66b0cec9948812b601e90ba6/doc/BUILDSPEC.md#format

    Parameters
    ----------
    purl: PackageURL
        The PackageURL to generate build spec for.
    session: sqlalchemy.orm.Session
        The SQLAlchemy Session opened for the database to extract build information.
    patches: Mapping[PatchCommandBuildTool, Mapping[str, PatchValueType | None]]
        The patches to apply to the build commands in ``build_info`` before being populated in
        the output Buildspec.

    Returns
    -------
    str | None
        The content of the Buildspec as string or None if there is an error.
        The errors that can happen are: 1. The input PURL is invalid, 2. There is no supported build tool
        for this PURL, 3. Failed to patch the build commands using the provided ``patches``, 4. The database from
        ``session`` doesn't contain enough information.
    """
    internal_build_info = get_rc_internal_build_info(
        purl=purl,
        session=session,
    )

    if not internal_build_info:
        logger.error(
            "Failed to obtain necessary data for purl %s from the database.",
            purl,
        )
        return None

    return _gen_reproducible_central_build_spec(
        build_info=internal_build_info,
        patches=patches,
    )
