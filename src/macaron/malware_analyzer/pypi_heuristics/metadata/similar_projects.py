# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This analyzer checks if the package has a similar structure to other packages maintained by the same user."""

import hashlib
import logging

from macaron.json_tools import JsonType
from macaron.malware_analyzer.pypi_heuristics.base_analyzer import BaseHeuristicAnalyzer
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult, Heuristics
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIInspectorAsset, PyPIPackageJsonAsset

logger: logging.Logger = logging.getLogger(__name__)


class SimilarProjectAnalyzer(BaseHeuristicAnalyzer):
    """Check whether the package has a similar structure to other packages maintained by the same user."""

    def __init__(self) -> None:
        super().__init__(
            name="similar_project_analyzer",
            heuristic=Heuristics.SIMILAR_PROJECTS,
            depends_on=None,
        )

    def analyze(self, pypi_package_json: PyPIPackageJsonAsset) -> tuple[HeuristicResult, dict[str, JsonType]]:
        """Analyze the package.

        Parameters
        ----------
        pypi_package_json: PyPIPackageJsonAsset
            The PyPI package JSON asset object.

        Returns
        -------
        tuple[HeuristicResult, dict[str, JsonType]]:
            The result and related information collected during the analysis.

        Raises
        ------
        HeuristicAnalyzerValueError
            if the analysis fails.
        """
        target_structure = self.get_normalized_structure(pypi_package_json)
        if not target_structure:
            return HeuristicResult.SKIP, {}
        target_hash = hashlib.sha256("\n".join(target_structure).encode("utf-8")).hexdigest()
        detail_info: dict = {}
        similar_projects: list[str] = []
        result: HeuristicResult = HeuristicResult.PASS

        maintainers = pypi_package_json.pypi_registry.get_maintainers_of_package(pypi_package_json.component_name)
        if not maintainers:
            # NOTE: This would ideally raise an error, identifying malformed package information, but issues with
            # obtaining maintainer information from the HTML page means this will remains as a SKIP for now.
            return HeuristicResult.SKIP, {}

        analyzed: set[str] = {pypi_package_json.component_name}

        for maintainer in maintainers:
            maintainer_packages = pypi_package_json.pypi_registry.get_packages_by_username(maintainer)
            if not maintainer_packages:
                continue
            for package in maintainer_packages:
                # Skip if it is a package we have already analyzed
                if package in analyzed:
                    continue
                analyzed.add(package)

                adjacent_pypi_json = PyPIPackageJsonAsset(
                    package,
                    None,
                    False,
                    pypi_package_json.pypi_registry,
                    {},
                    "",
                    "",
                    "",
                    PyPIInspectorAsset("", [], {}),
                )
                if not adjacent_pypi_json.download(""):
                    continue
                structure = self.get_normalized_structure(adjacent_pypi_json)
                if not structure:
                    continue

                hash_value = hashlib.sha256("\n".join(structure).encode("utf-8")).hexdigest()
                if target_hash == hash_value:
                    similar_projects.append(package)

        detail_info["similar_projects"] = similar_projects
        if similar_projects:
            result = HeuristicResult.FAIL

        return result, detail_info

    def get_normalized_structure(self, pypi_package_json: PyPIPackageJsonAsset) -> set[str] | None:
        """Extract a normalized structure for a package.

        The normalized structure is the file tree structure of all python file in the package, with the package's
        name removed, so it is comparable.

        Parameters
        ----------
        pypi_package_json: PyPIPackageJsonAsset
            The PyPI package JSON asset object.

        Returns
        -------
        set[str] | None:
            The normalized structure of file paths in a set, or None if a problem was encountered.
        """
        if not pypi_package_json.get_inspector_src_preview_links():
            return None

        # For normalizing the structure
        version = pypi_package_json.component_version
        if version is None:
            version = pypi_package_json.get_latest_version()
        if version is None:
            return None

        prefix = "./" + pypi_package_json.component_name + "-" + version
        normalized_structure = set()

        # Try using the tarball first
        tarball_link = pypi_package_json.inspector_asset.package_sdist_link
        if tarball_link and pypi_package_json.inspector_asset.package_link_reachability[tarball_link]:
            # All files are always prefixed with ./<package_name>-<version>/<...> in tarballs
            # Non-metadaata files then have <package_name>/
            # Prefix += "/" + pypi_package_json.component_name + "/"
            structure = PyPIInspectorAsset.get_structure(tarball_link)
            if structure:
                for file_path in structure:
                    # We only consider python files. This avoids considering always package-specific files like PKG_INFO, licenses,
                    # Build metadata, etc.
                    if file_path[-3:] != ".py":
                        continue

                    # Remove the "/package_name" from the prefix as well, that way the structure between two packages with different
                    # Names will be the same
                    normalized_structure.add(
                        file_path.removeprefix(prefix).removeprefix("/" + pypi_package_json.component_name)
                    )

                # We can't compare against wheel structures if we keep setup.py in there
                normalized_structure.discard("/setup.py")
                return normalized_structure

        wheel_links = pypi_package_json.inspector_asset.package_whl_links
        if len(wheel_links) > 0:
            # Wheels have this extra field for package metadata
            prefix += ".dist-info/"
            # Structure is generally going to be the same, platform-specific details may vary for pacakges
            # Which have platform-specific wheels
            structure = PyPIInspectorAsset.get_structure(wheel_links[0])
            if structure:
                for file_path in structure:
                    # The .dist-info stuff is usually metadata
                    if file_path.startswith(prefix) or file_path[-3:] != ".py":
                        continue

                    # Remove the "./package_name" from the prefix as well, that way the structure between
                    # Two packages with different names will be the same
                    normalized_structure.add(
                        file_path.removeprefix(pypi_package_json.component_name + "/").removeprefix(
                            "./" + pypi_package_json.component_name
                        )
                    )

                return normalized_structure

        # Doesn't have wheel or tarball links even made, so shouldn't get here if the first line of this
        # function worked.
        return None
