# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This analyzer checks if the package has a similar structure to other packages maintained by the same user."""

import hashlib
import io
import logging
import tarfile

from macaron.json_tools import JsonType
from macaron.malware_analyzer.pypi_heuristics.base_analyzer import BaseHeuristicAnalyzer
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult, Heuristics
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIPackageJsonAsset
from macaron.util import send_get_http, send_get_http_raw

logger: logging.Logger = logging.getLogger(__name__)


class SimilarProjectAnalyzer(BaseHeuristicAnalyzer):
    """Check whether the package has a similar structure to other packages maintained by the same user."""

    def __init__(self) -> None:
        super().__init__(
            name="similar_project_analyzer",
            heuristic=Heuristics.SIMILAR_PROJECTS,
            # TODO: these dependencies are used as this heuristic currently downloads many package sourcecode
            # tarballs. Refactoring this heuristic to run more efficiently means this should have depends_on=None.
            depends_on=[
                (Heuristics.EMPTY_PROJECT_LINK, HeuristicResult.FAIL),
                (Heuristics.ONE_RELEASE, HeuristicResult.FAIL),
                (Heuristics.HIGH_RELEASE_FREQUENCY, HeuristicResult.FAIL),
                (Heuristics.UNCHANGED_RELEASE, HeuristicResult.FAIL),
                (Heuristics.CLOSER_RELEASE_JOIN_DATE, HeuristicResult.FAIL),
                (Heuristics.SUSPICIOUS_SETUP, HeuristicResult.FAIL),
                (Heuristics.WHEEL_ABSENCE, HeuristicResult.FAIL),
                (Heuristics.ANOMALOUS_VERSION, HeuristicResult.FAIL),
                (Heuristics.TYPOSQUATTING_PRESENCE, HeuristicResult.FAIL),
                (Heuristics.FAKE_EMAIL, HeuristicResult.FAIL),
            ],
        )

    def analyze(self, pypi_package_json: PyPIPackageJsonAsset) -> tuple[HeuristicResult, dict[str, JsonType]]:
        """Analyze the package.

        Parameters
        ----------
        pypi_package_json: PyPIPackageJsonAsset
            The PyPI package JSON asset object.

        Returns
        -------
        tuple[HeuristicResult, dict[str, JsonType]]:
            The result and related information collected during the analysis.

        Raises
        ------
        HeuristicAnalyzerValueError
            if the analysis fails.
        """
        package_name = pypi_package_json.component_name
        target_hash = self.get_structure_hash(package_name)
        if not target_hash:
            return HeuristicResult.SKIP, {}

        maintainers = pypi_package_json.pypi_registry.get_maintainers_of_package(package_name)
        if maintainers:
            for maintainer in maintainers:
                maintainer_packages = pypi_package_json.pypi_registry.get_packages_by_username(maintainer)
                if not maintainer_packages:
                    continue
                for package in maintainer_packages:
                    if package == package_name:
                        continue

                    hash_value = self.get_structure_hash(package)
                    if target_hash == hash_value:
                        return HeuristicResult.FAIL, {
                            "message": f"The package {package_name} has a similar structure to {package}.",
                            "similar_package": package,
                        }

        return HeuristicResult.PASS, {}

    def get_url(self, package_name: str, package_type: str = "sdist") -> str | None:
        """Get the URL of the package's sdist.

        Parameters
        ----------
        package_name : str
            The name of the package.
        package_type: str
            The package type to retrieve the URL of.

        Returns
        -------
        str | None:
            The URL of the package's sdist or None if not found.
        """
        json_url = f"https://pypi.org/pypi/{package_name}/json"
        data = send_get_http(json_url, headers={})
        if not data:
            logger.debug("Failed to fetch package data for %s.", package_name)
            return None

        sdist = next((url for url in data["urls"] if url["packagetype"] == package_type and url.get("url")), None)
        return sdist["url"] if sdist else None

    def get_structure(self, package_name: str) -> list[str]:
        """Get the file structure of the package's sdist.

        Parameters
        ----------
        package_name : str
            The name of the package.

        Returns
        -------
        list[str]:
            The list of files in the package's sdist.
        """
        # TODO: We should not download the source distributions for every package.
        # This is very inefficient. We should find a different way to extract the package
        # structure, e.g., the inspector service?
        sdist_url = self.get_url(package_name)
        if not sdist_url:
            logger.debug("Package %s does not have a sdist.", package_name)
            return []

        response = send_get_http_raw(sdist_url)
        if not response:
            logger.debug("Failed to download sdist for package %s.", package_name)
            return []

        buffer = io.BytesIO(response.content)
        try:
            with tarfile.open(fileobj=buffer, mode="r:gz") as tf:
                members = [
                    member.name
                    for member in tf.getmembers()
                    if member.name and not member.name.startswith("PAXHeaders/")
                ]
        except (tarfile.TarError, OSError) as error:
            logger.debug("Error reading source code tar file: %s", error)
            return []

        return members

    def get_structure_hash(self, package_name: str) -> str:
        """Get the hash of the package's file structure.

        Parameters
        ----------
        package_name : str
            The name of the package.

        Returns
        -------
        str:
            The hash of the package's file structure.
        """
        structure = self.get_structure(package_name)
        if not structure:
            return ""

        normalized = sorted([p.replace(package_name, "<ROOT>") for p in structure])

        joined = "\n".join(normalized).encode("utf-8")
        return hashlib.sha256(joined).hexdigest()
