# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This analyzer checks the suspicious pattern within setup.py."""

import ast
import logging
import os
import re
import tarfile
import tempfile
import zipfile

import requests
from requests import RequestException

from macaron.json_tools import JsonType
from macaron.malware_analyzer.pypi_heuristics.base_analyzer import BaseHeuristicAnalyzer
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult, Heuristics
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIPackageJsonAsset

logger: logging.Logger = logging.getLogger(__name__)


class SuspiciousSetupAnalyzer(BaseHeuristicAnalyzer):
    """Check whether suspicious packages are imported in setup.py."""

    def __init__(self) -> None:
        super().__init__(
            name="suspicious_setup_analyzer",
            heuristic=Heuristics.SUSPICIOUS_SETUP,
            depends_on=[(Heuristics.CLOSER_RELEASE_JOIN_DATE, HeuristicResult.FAIL)],
        )
        self.blacklist: list = ["base64", "request"]

    def _get_setup_source_code(self, pypi_package_json: PyPIPackageJsonAsset) -> str | None:
        """Get the source code in setup.py.

        Parameters
        ----------
        pypi_package_json: PyPIPackageJsonAsset
            The PyPI package JSON asset object.

        Returns
        -------
        str | None
            The source code.
        """
        sourcecode_url: str | None = pypi_package_json.get_sourcecode_url()
        if sourcecode_url is None:
            return None

        # Get name of file.
        _, _, file_name = sourcecode_url.rpartition("/")

        # Create a temporary directory to store the downloaded source.
        with tempfile.TemporaryDirectory() as temp_dir:
            try:
                response = requests.get(sourcecode_url, stream=True, timeout=40)
                response.raise_for_status()
            except requests.exceptions.HTTPError as http_err:
                logger.debug("HTTP error occurred: %s", http_err)
                return None

            if response.status_code != 200:
                return None

            source_file = os.path.join(temp_dir, file_name)
            with open(source_file, "wb") as file:
                try:
                    for chunk in response.iter_content():
                        file.write(chunk)
                except RequestException as error:
                    # Something went wrong with the request, abort.
                    logger.debug("Error while streaming source file: %s", error)
                    response.close()
                    return None

            target_file = "setup.py"
            file_dir = file_name.removesuffix(".tar.gz").removesuffix(".zip")
            archive_target = os.path.join(file_dir, target_file)
            try:
                with tarfile.open(source_file, "r:gz") as tar:
                    member = tar.getmember(archive_target)
                    if not member.isfile():
                        logger.debug("Target tar member is not a file: %s", member)
                        return None
                    tar.extract(member=member, path=temp_dir)
            except KeyError as exception:
                logger.debug("Error finding target '%s' in tar file '%s': %s.", archive_target, source_file, exception)
                return None
            except tarfile.ReadError as exception:
                logger.debug("Error reading tar file: %s", exception)

                try:
                    with zipfile.ZipFile(source_file, "r") as zip_ref:
                        info = zip_ref.getinfo(archive_target)
                        if info.is_dir():
                            logger.debug("Target zip member is a directory: %s", info)
                            return None
                        zip_ref.extract(member=info, path=temp_dir)
                except zipfile.BadZipFile as bad_zip_exception:
                    logger.debug("Error reading zip file: %s", bad_zip_exception)
                except zipfile.LargeZipFile as large_zip_exception:
                    logger.debug("Zip file too large to read: %s", large_zip_exception)
                except KeyError as zip_key_exception:
                    logger.debug(
                        "Error finding target '%s' in zip file '%s': %s", archive_target, source_file, zip_key_exception
                    )
                    return None

            final_path = os.path.join(temp_dir, archive_target)
            # Check if file exists and is readable.
            if not os.access(final_path, os.R_OK):
                logger.debug("Source file could not be extracted and read from download archive: %s.", final_path)
                return None

            with open(final_path, encoding="utf-8") as file:
                return file.read()

    def analyze(self, pypi_package_json: PyPIPackageJsonAsset) -> tuple[HeuristicResult, dict[str, JsonType]]:
        """Analyze the package.

        Parameters
        ----------
        pypi_package_json: PyPIPackageJsonAsset
            The PyPI package JSON asset object.

        Returns
        -------
        tuple[HeuristicResult, dict[str, JsonType]]:
            The result and related information collected during the analysis.
        """
        content: str | None = self._get_setup_source_code(pypi_package_json)
        if content is None:
            return HeuristicResult.SKIP, {}

        # Catch the imported module.
        try:
            imports = self.extract_from_ast(content)
        except SyntaxError:
            imports = self.extract_from_lines(content)

        # Catch the install_requires packages
        pattern = r"install_requires\s*=\s*\[(.*?)\]"
        matches = re.search(pattern, content, re.DOTALL)
        if matches:
            imports.update(set(re.findall(r"'(.*?)'", matches.group(1))))

        suspicious_setup = any(suspicious_keyword in imp for imp in imports for suspicious_keyword in self.blacklist)
        if suspicious_setup:
            return HeuristicResult.FAIL, {"import_module": list(imports)}
        return HeuristicResult.PASS, {"import_module": list(imports)}

    def extract_from_ast(self, source_content: str) -> set[str]:
        """Extract imports from source code using the parsed AST.

        Parameters
        ----------
        source_content: str
            The source code as a string.

        Returns
        -------
        set[str]
            The set of imports.

        Raises
        ------
        SyntaxError
            If the code could not be parsed.
        """
        imports = set()
        tree = ast.parse(source_content)
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                module = node.module
                if module:
                    _module = "." * node.level + module
                    imports.add(_module)
                    for name in node.names:
                        imports.add(_module + "." + name.name)

        return imports

    def extract_from_lines(self, source_content: str) -> set[str]:
        """Extract imports from source code using per line pattern matching.

        Parameters
        ----------
        source_content: str
            The source code as a string.

        Returns
        -------
        set[str]
            The list of imports.
        """
        alias_pattern = r"\s+as\s+\w+(?:\.{0,1}\w+)*"
        # Pattern for module aliases.

        module_name = r"\w+(?:\.{0,1}\w+"
        # <module_name> as described under pattern_import.

        pattern_import = (
            r"(?:import\s+)(" + module_name + r")*(?:" + alias_pattern + r")?"
            r"(?:(?:\s*,\s*)(?:" + module_name + r")*(?:" + alias_pattern + r")?))*)(?:(?:\s|#).*)?"
        )
        # Allows for a standard import statement.
        # E.g.: import <module_name(s)> <other_text>
        # Where <module_name(s)> consists of one or more <module_name>.
        # Where <module_name> consists of one or more words (a-z or 0-9 or underscore) separated by periods,
        # with an optional alias.
        # Where <other_text> allows any character(s) either after a single space or a hash (#).

        pattern_from_import = (
            r"(?:from\s+)([.]*"
            + module_name
            + r")*)(?:\s+import\s+(\w+(?:\s+as\s+\w+)?(?:(?:\s*,\s*)(?:\w+(?:\s+as\s+\w+)?))*))"
        )
        # Allows for a from import statement.
        # E.g.: from <module_name> import <module_component(s)> <other_text>
        # Where <module_name> is as above, but can also be preceded by any number of periods.
        # (Note only a single module can be placed here.)
        # Where <module_component(s)> consists of one or more <module_component> with optional aliases.
        # Where <module_component> is identical to <module_name> except without any periods.
        # Where <other_text> requires at least one space followed by one or more word characters, plus
        # any other characters following on from that.

        combined_pattern = f"^(?:{pattern_import})|(?:{pattern_from_import})$"
        # The combined pattern creates two match groups:
        # 1 - standard import statement.
        # 2 - from import statement module.
        # 3 - from import statement module components.

        imports = set()
        for line in source_content.splitlines():
            line.strip()
            match = re.match(combined_pattern, line)
            if not match:
                continue

            if match.group(1):
                # Standard import, handle commas and aliases if present.
                splits = self._prune_aliased_lines(match.group(1), alias_pattern)
                for split in splits:
                    imports.add(split)
            elif match.group(2):
                # From import
                imports.add(match.group(2))
                if match.group(3):
                    splits = self._prune_aliased_lines(match.group(3), alias_pattern)
                    for split in splits:
                        imports.add(match.group(2) + "." + split)

        return imports

    def _prune_aliased_lines(self, text: str, alias_pattern: str) -> list[str]:
        """Split the line on commas and remove any aliases from individual parts."""
        results = []
        splits = text.split(",")
        for split in splits:
            split = split.strip()
            results.append(re.sub(alias_pattern, "", split))
        return results
