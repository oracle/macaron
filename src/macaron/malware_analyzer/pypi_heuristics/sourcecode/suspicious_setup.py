# Copyright (c) 2024 - 2024, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This analyzer checks the suspicious pattern within setup.py."""

import ast
import logging
import os
import re
import tarfile
import tempfile
import zipfile

import requests

from macaron.malware_analyzer.pypi_heuristics.base_analyzer import BaseHeuristicAnalyzer
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult, Heuristics
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIRegistry

logger: logging.Logger = logging.getLogger(__name__)


class SuspiciousSetupAnalyzer(BaseHeuristicAnalyzer):
    """Analyzer checks heuristic."""

    def __init__(self) -> None:
        super().__init__(name="suspicious_setup_analyzer", heuristic=Heuristics.SUSPICIOUS_SETUP, depends_on=None)
        self.blacklist: list = ["base64", "request"]

    def _get_setup_source_code(self, api_client: PyPIRegistry) -> str | None:
        """Get the source code in setup.py.

        Parameters
        ----------
            package_name (str): PyPI package's name
            version (str): The version of the package
            destination_dir (str): The location of the tmp

        Returns
        -------
            str | None: Source code.
        """
        # Create a temporary directory to store the downloaded source
        with tempfile.TemporaryDirectory() as temp_dir:
            sourcecode_url: str | None = api_client.get_sourcecode_url()
            if sourcecode_url is None:
                return None
            try:
                response = requests.get(sourcecode_url, stream=True, timeout=40)
                response.raise_for_status()
            except requests.exceptions.HTTPError as http_err:
                logger.debug("HTTP error occurred: %s", http_err)
                return None

            with open(os.path.join(temp_dir, "tmp"), "wb") as f:
                f.write(response.content)

            files = os.listdir(temp_dir)
            try:
                with tarfile.open(os.path.join(temp_dir, files[0]), "r:gz") as tar:
                    tar.extractall(temp_dir)  # nosec B202
            except tarfile.ReadError as exception:
                logger.debug("Error reading tar file: %s", exception)

                try:
                    with zipfile.ZipFile(os.path.join(temp_dir, files[0]), "r") as zip_ref:
                        zip_ref.extractall(temp_dir)  # nosec B202
                except zipfile.BadZipFile as bad_zip_exception:
                    logger.debug("Error reading zip file: %s", bad_zip_exception)
                except zipfile.LargeZipFile as large_zip_exception:
                    logger.debug("Zip file too large to read: %s", large_zip_exception)

            for root, _, files in os.walk(temp_dir):
                for file in files:
                    if file == "setup.py":
                        file_path = os.path.join(root, file)
                        with open(file_path, encoding="utf-8") as py_file:
                            return py_file.read()
            return None

    def analyze(self, api_client: PyPIRegistry) -> tuple[HeuristicResult, dict]:
        """Analyze suspicious packages are imported in setup.py.

        Returns
        -------
            tuple[HeuristicResult, Confidence | None]: Result and confidence.
        """
        content: str | None = self._get_setup_source_code(api_client)
        if content is None:
            return HeuristicResult.SKIP, {}

        imports = set()
        # Catch the imported module
        try:
            tree = ast.parse(content)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.add(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    module = node.module
                    if node.level > 0 and module:
                        _module = "." * node.level + module
                        for alias in node.names:
                            if alias.name:
                                import_name = _module + "." + alias.name
                                imports.add(import_name)
        except SyntaxError:
            pattern = r"^\s*import\s+(\w+)(?:\s+as\s+\w+)?(?:\s*,\s*\w+)*\s*$|^\s*from\s+(\w+)\s+import\s+\w+ \
            (?:\s+as\s+\w+)?(?:\s*,\s*\w+(?:\s+as\s+\w+)?)*\s*$"
            for line in content.splitlines():
                match = re.match(pattern, line)
                if match:
                    imports.update(filter(None, match.groups()))

        # Catch the install_requires packages
        pattern = r"install_requires\s*=\s*\[(.*?)\]"
        matches = re.search(pattern, content, re.DOTALL)
        if matches:
            imports.update(set(re.findall(r"'(.*?)'", matches.group(1))))

        suspicious_setup = any(suspicious_keyword in imp for imp in imports for suspicious_keyword in self.blacklist)
        if suspicious_setup:
            return HeuristicResult.FAIL, {"import_module": imports}
        return HeuristicResult.PASS, {"import_module": imports}
