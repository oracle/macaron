# Copyright (c) 2024 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""
Detect suspicious function calls in the code and trace the arguments back to their original values.

This allows for deeper analysis of potentially malicious behavior.
"""

import glob
import json
import logging
import os
import subprocess  # nosec
import tempfile

import yaml

from macaron.config.defaults import defaults
from macaron.config.global_config import global_config
from macaron.errors import ConfigurationError, HeuristicAnalyzerValueError
from macaron.json_tools import JsonType, json_extract
from macaron.malware_analyzer.pypi_heuristics.base_analyzer import BaseHeuristicAnalyzer
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult, Heuristics
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIPackageJsonAsset

logger: logging.Logger = logging.getLogger(__name__)


class PyPISourcecodeAnalyzer(BaseHeuristicAnalyzer):
    """This class is used to analyze the source code of python PyPI packages. This analyzer is a work in progress.

    Currently the analyzer performs textual pattern matching and dataflow analysis using the open-source features of
    Semgrep. Semgrep open-source taint tracking can only perform in one locale, but this is a known limitation. Default
    rules are stored in 'macaron/resources/pypi_malware_rules' as semgrep .yaml rule files. A user may add additional
    rules stored in a specified directory passed by them in the 'defaults.ini' configuration file.
    """

    def __init__(self, resources_path: str | None = None) -> None:
        """
        Initialise the source code analyzer and load default and custom semgrep rulesets.

        Parameters
        ----------
        resources_path: str | None
            The path to the resources directory which must contain a 'pypi_malware_rules' directory of
            semgrep rules. If None is provided, then this is loaded from the global config resources path.
            Defaults to None

        Raises
        ------
        ConfigurationError
            If the default rule path is invalid, the heuristic.pypi entry is not present, or if the semgrep
            validation of the custom rule path failed.
        """
        super().__init__(
            name="suspicious_patterns_analyzer",
            heuristic=Heuristics.SUSPICIOUS_PATTERNS,
            # We include the SKIP condition here as we want to consider the case where EMPTY_PROJECT_LINK fails,
            # meaning SOURCE_CODE_REPO is skipped, as this is still a scenario where the source code repository
            # is not available, so we want to run source code analysis.
            depends_on=[
                (Heuristics.SOURCE_CODE_REPO, HeuristicResult.FAIL),
                (Heuristics.SOURCE_CODE_REPO, HeuristicResult.SKIP),
            ],
        )
        if resources_path is None:
            resources_path = global_config.resources_path
        self.default_rule_path, self.custom_rule_path, self.disabled_rule_ids = self._load_defaults(resources_path)

    def _load_defaults(self, resources_path: str) -> tuple[str, str | None, set[str]]:
        """
        Load the default semgrep rules and, if present, the custom semgrep rules provided by the user.

        Semgrep validation is run on the custom rules provided by the user.

        Parameters
        ----------
        resources_path: str
            The path to the resources directory which must contain a 'pypi_malware_rules' directory of
            semgrep rules.

        Returns
        -------
        tuple[str, str | None]
            The default rule path and the custom rule path or None if one was not provided

        Raises
        ------
        ConfigurationError
            If the default rule path is invalid, the heuristic.pypi entry is not present, or if the semgrep
            validation of the custom rule path failed.
        """
        default_rule_path = os.path.join(resources_path, "pypi_malware_rules")
        if not os.path.exists(default_rule_path):
            error_msg = f"Error with locating default rule path {default_rule_path}"
            logger.debug(error_msg)
            raise ConfigurationError(error_msg)

        section_name = "heuristic.pypi"

        if defaults.has_section(section_name):
            section = defaults[section_name]
        else:
            error_msg = f"Unable to find section {section_name}, which must be present."
            logger.debug(error_msg)
            raise ConfigurationError(error_msg)

        configuration_name = "custom_semgrep_rules_path"
        custom_rule_path = section.get(configuration_name)
        if not custom_rule_path:  # i.e. None or empty string
            logger.debug("No custom path listed under %s, using default rules only.", configuration_name)
            custom_rule_path = None
        else:
            custom_rule_path = os.path.normpath(custom_rule_path)
            if not os.path.exists(custom_rule_path):
                error_msg = f"Unable to locate path {custom_rule_path}"
                logger.debug(error_msg)
                raise ConfigurationError(error_msg)

            semgrep_commands: list[str] = ["semgrep", "scan", "--validate", "--oss-only", "--config", custom_rule_path]
            try:
                process = subprocess.run(semgrep_commands, check=True, capture_output=True)  # nosec
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as semgrep_error:
                error_msg = (
                    f"Unable to run semgrep validation on {custom_rule_path} with arguments "
                    f"{semgrep_commands}: {semgrep_error}."
                )
                logger.debug(error_msg)
                raise ConfigurationError(error_msg) from semgrep_error

            if process.returncode != 0:
                error_msg = f"Error running semgrep validation on {custom_rule_path} with arguments" f" {process.args}."
                logger.debug(error_msg)
                raise ConfigurationError(error_msg)

            logger.debug("Including custom ruleset from %s.", custom_rule_path)

        disabled_rule_ids = set()

        disabled_default_rulesets = defaults.get_list(section_name, "disabled_default_rulesets")
        if disabled_default_rulesets:
            target_files = {f"{name}.yaml" for name in disabled_default_rulesets}
            disabled_rule_ids.update(self._extract_rule_ids(default_rule_path, target_files))

        disabled_custom_rulesets = defaults.get_list(section_name, "disabled_custom_rulesets")
        if disabled_custom_rulesets:
            if custom_rule_path:
                target_files = {f"{name}.yaml" for name in disabled_custom_rulesets}
                disabled_rule_ids.update(self._extract_rule_ids(custom_rule_path, target_files))
            else:
                logger.warning("Disabled custom rulesets provided without a set of custom rulesets. Ignoring.")

        disabled_rules = defaults.get_list(section_name, "disabled_rules")
        if disabled_rules:
            disabled_rule_ids.update(set(disabled_rules))

        if disabled_rule_ids:
            logger.debug("Disabling the following rules: %s.", disabled_rule_ids)

        return default_rule_path, custom_rule_path, disabled_rule_ids

    def _extract_rule_ids(self, path: str, target_files: set[str]) -> set[str]:
        """
        Extract Semgrep rule IDs from a set of target .yaml Semgrep rules nested inside the provided path.

        Raise an error when not all target Semgrep rule files are found in the provided path or subdirectories
        of the provided path.

        Parameters
        ----------
        path: str
            The path that includes the target Semgrep rules in it or subdirectories of it.
        target_files: set[str]
            A set of unique Semgrep rule file names (with their .yaml extension) to find in the provided path.

        Returns
        -------
        set[str]
            A set of unique Semgrep rule IDs extracted from all provided target files.

        Raises
        ------
        ConfigurationError
            If any Semgrep rule file could not be safely loaded, or if their format was not in the expected Semgrep
            format, or if there were any files in 'target_files' not found when searching in 'path'.
        """
        # We keep a record of any file paths we coulnd't find to provide a more useful error message, rather than raising
        # an error on the first missing file we see.
        missing_files: list[str] = []
        target_file_paths: list[str] = []
        rule_ids: set[str] = set()

        for target_file in target_files:
            file_paths = glob.glob(os.path.join(path, "**", target_file), recursive=True)
            if not file_paths:
                missing_files.append(target_file)
            target_file_paths.extend(file_paths)

        if missing_files:
            error_msg = f"The following semgrep files were not found in {path}: {missing_files}"
            logger.debug(error_msg)
            raise ConfigurationError(error_msg)

        for file_path in target_file_paths:
            try:
                with open(file_path, encoding="utf-8") as file:
                    semgrep_ruleset: dict[str, list] = yaml.safe_load(file.read())
            except yaml.YAMLError as yaml_error:
                error_msg = f"Unable to open semgrep rule file {file_path}: {yaml_error}."
                logger.debug(error_msg)
                raise ConfigurationError(error_msg) from yaml_error

            # should be a top-level key "rules", and then a list of rules (dictionaries) with "id" entries
            try:
                for semgrep_rule in semgrep_ruleset["rules"]:
                    rule_ids.add(semgrep_rule["id"])
            except (KeyError, TypeError) as format_error:
                error_msg = f"Invalid semgrep rule format for {file_path}: {format_error}."
                logger.debug(error_msg)
                raise ConfigurationError(error_msg) from format_error

        return rule_ids

    def analyze(self, pypi_package_json: PyPIPackageJsonAsset) -> tuple[HeuristicResult, dict[str, JsonType]]:
        """Analyze the source code of the package for malicious patterns.

        This is the first phase of the source code analyzer.

        Parameters
        ----------
        pypi_package_json: PyPIPackageJsonAsset
            The PyPI package JSON asset object.

        Returns
        -------
        tuple[HeuristicResult, dict[str, JsonType]]
            Containing the analysis results and relevant patterns identified.

        Raises
        ------
        HeuristicAnalyzerValueError
            if there is no source code available.
        """
        analysis_result: dict = {}
        # since we have to run them anyway, return disabled rule findings for debug information
        disabled_results: dict = {}
        # Here, we disable 'nosemgrep' ignoring so that this is not an evasion method of our scan (i.e. malware includes
        # 'nosemgrep' comments to prevent our scan detecting those code lines). Read more about the 'nosemgrep' feature
        # here: https://semgrep.dev/docs/ignoring-files-folders-code
        semgrep_commands: list[str] = ["semgrep", "scan", "--oss-only", "--disable-nosem"]
        result: HeuristicResult = HeuristicResult.PASS

        source_code_path = pypi_package_json.package_sourcecode_path
        if not source_code_path:
            error_msg = "Unable to retrieve PyPI package source code path"
            logger.debug(error_msg)
            raise HeuristicAnalyzerValueError(error_msg)

        semgrep_commands.extend(["--config", self.default_rule_path])
        if self.custom_rule_path:
            semgrep_commands.extend(["--config", self.custom_rule_path])
        semgrep_commands.append(source_code_path)

        with tempfile.NamedTemporaryFile(mode="w+", delete=True) as output_json_file:
            semgrep_commands.append(f"--json-output={output_json_file.name}")
            logger.debug("executing: %s.", semgrep_commands)
            try:
                process = subprocess.run(semgrep_commands, check=True, capture_output=True)  # nosec
            except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as semgrep_error:
                error_msg = (
                    f"Unable to run semgrep on {source_code_path} with arguments {semgrep_commands}: {semgrep_error}"
                )
                logger.debug(error_msg)
                raise HeuristicAnalyzerValueError(error_msg) from semgrep_error

            if process.returncode != 0:
                error_msg = f"Error running semgrep on {source_code_path} with arguments" f" {process.args}"
                logger.debug(error_msg)
                raise HeuristicAnalyzerValueError(error_msg)

            try:
                semgrep_output = json.loads(output_json_file.read())
            except (json.JSONDecodeError, UnicodeDecodeError) as output_read_error:
                error_msg = f"Unable to read Semgrep JSON output: {output_read_error}"
                logger.debug(error_msg)
                raise HeuristicAnalyzerValueError(error_msg) from output_read_error

        if not semgrep_output:
            return result, {}

        semgrep_findings = json_extract(semgrep_output, ["results"], list)
        if not semgrep_findings:
            return result, {}

        for finding in semgrep_findings:
            rule_id = json_extract(finding, ["check_id"], str)
            file = json_extract(finding, ["path"], str)
            if not rule_id or not file:
                continue

            file = os.path.relpath(file, os.path.dirname(source_code_path))
            start = json_extract(finding, ["start", "line"], int)
            end = json_extract(finding, ["end", "line"], int)
            message = json_extract(finding, ["extra", "message"], str)

            # We manually filter out disabled rule IDs, as Semgrep's command line argument `--exclude-rule` appears to
            # only work if `--experimental` is also supplied to enable experimental features, which we do not use.
            # Semgrep provides a relative path separated by '.' to the rule ID, where the rule ID is always the
            # final element in that path, so we use that to match our rule IDs.
            # e.g. rule_id = src.macaron.resources.pypi_malware_rules.obfuscation_decode-and-execute, which comes from
            # the rule ID 'obfuscation_decode-and-execute' inside 'obfuscation.yaml'.
            if rule_id.split(".")[-1] in self.disabled_rule_ids:
                if rule_id not in disabled_results:
                    disabled_results[rule_id] = {"message": message, "detections": []}
                disabled_results[rule_id]["detections"].append({"file": file, "start": start, "end": end})

            else:
                if rule_id not in analysis_result:
                    analysis_result[rule_id] = {"message": message, "detections": []}
                analysis_result[rule_id]["detections"].append({"file": file, "start": start, "end": end})

        # some semgrep rules were triggered, even after removing disabled ones
        if analysis_result:
            result = HeuristicResult.FAIL

        return result, {
            "enabled_sourcecode_rule_findings": analysis_result,
            "disabled_sourcecode_rule_findings": disabled_results,
        }
