# Copyright (c) 2024 - 2024, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""
Detect suspicious function calls in the code and trace the arguments back to their original values.

This allows for deeper analysis of potentially malicious behavior.
"""

import ast
import base64
import binascii
import ipaddress
import logging
import os
import pathlib
import re

import yaml

from macaron.json_tools import JsonType
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIPackageJsonAsset

logger: logging.Logger = logging.getLogger(__name__)


class DataFlowTracer(ast.NodeVisitor):
    """The class is used to create the symbol table and analyze the dataflow."""

    def __init__(self) -> None:
        self.symbol_table: dict = {}  # Store variable assignments
        self.trace_path: list = []

    def visit_Assign(self, node: ast.Assign) -> None:  # noqa: N802 # pylint: disable=C0103
        """Visit the Assign node and build the symbol table."""
        for target in node.targets:
            if isinstance(target, ast.Name):
                target_name = target.id
                if isinstance(node.value, ast.Name):
                    self.symbol_table[target_name] = str(node.value.id)
                elif isinstance(node.value, ast.Constant):
                    self.symbol_table[target_name] = str(node.value.value)
                # Handle other assignment types as needed (e.g., function calls, lists)
                else:
                    self.symbol_table[target_name] = ast.unparse(node.value)
        self.generic_visit(node)  # Important for visiting nested assign

    def trace_back(self, variable_name: str) -> list:
        """Get the full path of the dataflow.

        Parameters
        ----------
        variable_name: str
                The argument of the function call.

        Returns
        -------
        list
                The path of the dataflow.
        """
        self.trace_path = []
        self._recursive_trace(variable_name)
        return self.trace_path

    def _recursive_trace(self, variable_name: str) -> None:
        """Recursively build the dataflow path by analyzing the symbol table.

        Parameters
        ----------
        variable_name: str
                The argument of the function call.
        """
        if variable_name in self.symbol_table:
            value = self.symbol_table[variable_name]
            if not self.trace_path:
                self.trace_path.extend([variable_name, value])
            else:
                self.trace_path.append(value)
            if (
                isinstance(value, str) and value in self.symbol_table and self.symbol_table[value] != value
            ):  # only trace if it is a var name
                self._recursive_trace(value)

    def generate_symbol_table(self, source_code: str) -> None:
        """Generate the symbol table.

        Parameters
        ----------
        source_code: str
                The source code of the script.
        """
        tree = ast.parse(source_code)
        self.visit(tree)


class PyPISourcecodeAnalyzer:
    """This class is used to analyze the source code."""

    def __init__(self, pypi_package_json: PyPIPackageJsonAsset) -> None:
        """Collect required data for analysing the source code."""
        self.source_code: dict[str, str] | None = pypi_package_json.get_sourcecode()
        self.suspicious_pattern: dict[str, JsonType] | None = self._load_suspicious_pattern()
        # self.extracted_suspicious_content: dict[str, JsonType] = {}
        self.analysis_result: dict = {}
        self.is_malware: bool = False

    def analyze(self) -> tuple[bool, dict]:
        """Analyze the source code of the PyPI package.

        Returns
        -------
        dict
            The result of the analysis.
        """
        if self.source_code and self.suspicious_pattern:
            for filename, content in self.source_code.items():
                try:
                    imports = self._extract_imports_from_ast(content)
                except SyntaxError:
                    imports = self._extract_imports_from_lines(content)

                if isinstance(self.suspicious_pattern["imports"], list):
                    suspicious_imports: set[str] | None = imports & set(self.suspicious_pattern["imports"])
                else:
                    suspicious_imports = None

                # No suspicious imports in the source code. Skip the further steps.
                if not suspicious_imports:
                    logger.debug("No suspicious imports found in the file %s", filename)
                    continue

                # TODO: Currently the symbol table stores the data for dataflow analysis.
                # In the future, the dataflow will be more complicated and even handle the cross-file dataflow.
                tracer = DataFlowTracer()
                tracer.generate_symbol_table(content)
                logger.debug(tracer.symbol_table)

                # TODO: In the future, the probability policy to decide the file is malicious or not
                # will be implemented. Therefore, the functioncall_analyzer.analyze() will return detail_info
                # and analysis result.
                functioncall_analyzer = FunctionCallAnalyzer(self.suspicious_pattern, tracer)
                is_malware, detail_info = functioncall_analyzer.analyze(content)
                if is_malware:
                    self.is_malware = is_malware

                # TODO: Currently, the result collector does not handle the situation that
                # multiple same filename. In the future, this will be replace with absolute path.
                if detail_info:
                    self.analysis_result[filename] = detail_info

                # TODO: Implement other suspicious setup in suspicious_pattern.yaml
                # pattern = r"install_requires\s*=\s*\[(.*?)\]"
                # matches: re.Match | None = re.search(pattern, content, re.DOTALL)
                # if matches:
                #     install_requires: set[str] | None = set(re.findall(r"'(.*?)'", matches.group(1)))
                #     if (
                #         install_requires
                #         and install_requires & set(self.suspicious_pattern["imports"])
                #         and len(install_requires) < 4
                #         # This threshold is based on historical malwares
                #     ):
                #         extracted_data["install_requires"] = install_requires
            # TODO: In the future this result from each file will be used to calculate the probability.
            # Then the is_malicious will be based on this value.
            # Currently, the default policy is
        return self.is_malware, self.analysis_result

    # def extract_susupicious_content(self) -> None:
    #     """Extract the suspicious content from the source code."""
    #     if not self.source_code or not self.suspicious_pattern:
    #         return
    #     self.extracted_suspicious_content = self._extract_suspicious_content_from_source()

    def _load_suspicious_pattern(self) -> dict[str, JsonType] | None:
        """Load the suspicious pattern from suspicious_pattern.yaml.

        Returns
        -------
        dict[str, JsonType] | None
            The suspicious pattern.
        """
        filename: str = "suspicious_pattern.yaml"
        curr_dir: pathlib.Path = pathlib.Path(__file__).parent.absolute()
        suspicious_pattern_file: str = os.path.join(curr_dir, filename)
        with open(suspicious_pattern_file, encoding="utf-8") as file:
            try:
                suspicious_pattern: dict[str, JsonType] = yaml.safe_load(file)
            except yaml.YAMLError as yaml_exception:
                logger.debug("Error parsing the yaml file: '%s'", yaml_exception)
                return None
        return suspicious_pattern

    def _extract_imports_from_ast(self, content: str) -> set[str]:
        """Extract imports from source code using the parsed AST.

        Parameters
        ----------
        source_content: str
                The source code as a string.

        Returns
        -------
        set[str]
                The set of imports.

        Raises
        ------
        SyntaxError
                If the code could not be parsed.
        """
        imports = set()
        tree = ast.parse(content)
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                module = node.module
                if module:
                    _module = "." * node.level + module
                    imports.add(_module)
                    for name in node.names:
                        imports.add(_module + "." + name.name)

        return imports

    def _extract_imports_from_lines(self, content: str) -> set[str]:
        """Extract imports from source code using per line pattern matching.

        Parameters
        ----------
        source_content: str
                The source code as a string.

        Returns
        -------
        set[str]
                The list of imports.
        """
        alias_pattern = r"\s+as\s+\w+(?:\.{0,1}\w+)*"
        # Pattern for module aliases.

        module_name = r"\w+(?:\.{0,1}\w+"
        # <module_name> as described under pattern_import.

        pattern_import = (
            r"(?:import\s+)(" + module_name + r")*(?:" + alias_pattern + r")?"
            r"(?:(?:\s*,\s*)(?:" + module_name + r")*(?:" + alias_pattern + r")?))*)(?:(?:\s|#).*)?"
        )
        # Allows for a standard import statement.
        # E.g.: import <module_name(s)> <other_text>
        # Where <module_name(s)> consists of one or more <module_name>.
        # Where <module_name> consists of one or more words (a-z or 0-9 or underscore) separated by periods,
        # with an optional alias.
        # Where <other_text> allows any character(s) either after a single space or a hash (#).

        pattern_from_import = (
            r"(?:from\s+)([.]*"
            + module_name
            + r")*)(?:\s+import\s+(\w+(?:\s+as\s+\w+)?(?:(?:\s*,\s*)(?:\w+(?:\s+as\s+\w+)?))*))"
        )
        # Allows for a from import statement.
        # E.g.: from <module_name> import <module_component(s)> <other_text>
        # Where <module_name> is as above, but can also be preceded by any number of periods.
        # (Note only a single module can be placed here.)
        # Where <module_component(s)> consists of one or more <module_component> with optional aliases.
        # Where <module_component> is identical to <module_name> except without any periods.
        # Where <other_text> requires at least one space followed by one or more word characters, plus
        # any other characters following on from that.

        combined_pattern = f"^(?:{pattern_import})|(?:{pattern_from_import})$"
        # The combined pattern creates two match groups:
        # 1 - standard import statement.
        # 2 - from import statement module.
        # 3 - from import statement module components.

        imports = set()
        for line in content.splitlines():
            line.strip()
            match = re.match(combined_pattern, line)
            if not match:
                continue

            if match.group(1):
                # Standard import, handle commas and aliases if present.
                splits = self._prune_aliased_lines(match.group(1), alias_pattern)
                for split in splits:
                    imports.add(split)
            elif match.group(2):
                # From import
                imports.add(match.group(2))
                if match.group(3):
                    splits = self._prune_aliased_lines(match.group(3), alias_pattern)
                    for split in splits:
                        imports.add(match.group(2) + "." + split)

        return imports

    def _prune_aliased_lines(self, text: str, alias_pattern: str) -> list[str]:
        """Split the line on commas and remove any aliases from individual parts."""
        results = []
        splits = text.split(",")
        for split in splits:
            split = split.strip()
            results.append(re.sub(alias_pattern, "", split))
        return results


class FunctionCallAnalyzer(ast.NodeVisitor):
    """This class analyzes Python source code to identify potential suspicious behavior."""

    def __init__(self, suspicious_pattern: dict, tracer: DataFlowTracer) -> None:
        """Initialize the analyzer.

        Parameters
        ----------
        suspicious_pattern: dict
                The suspicious behaviour mainly includes the function call and constant.
        """
        self.suspicious_patterns: dict = suspicious_pattern
        self.analysis_detail: dict = {
            "OS Detection": {},
            "Code Execution": {},
            "Information Collecting": {},
            "Remote Connection": {},
            "Custom Setup": {},
            "Obfuscation": {},
        }
        self.tracer = tracer
        self.is_malware = False

    def visit_Module(self, node: ast.Module) -> None:  # noqa: N802 # pylint: disable=C0103
        """Visit all root node."""
        self.generic_visit(node)

    # TODO: Detect OS might generate false alert.
    # def visit_If(self, node: ast.If) -> None:
    #     """Visit the If node."""
    #     if isinstance(node.test, ast.Compare):
    #         unparsed_expr: str = ast.unparse(node)
    #         # Some malware excute different malicious code based on the victims OS.
    #         for os_detection_constant in self.suspicious_patterns["ast_constant"]["os_detection"]:
    #             if os_detection_constant in unparsed_expr:
    # TODO: This function is required to be implemented with dataflow analysis
    #                 self.analysis_detail["OS Detection"][node.lineno] = unparsed_expr
    #                 self.is_malware = True
    #     self.generic_visit(node)

    def visit_Call(self, node: ast.Call) -> None:  # noqa: N802 # pylint: disable=C0103
        """Visit the Call node."""
        suspicious_calls: dict = self.suspicious_patterns["ast_calls"]
        suspicious_const: dict = self.suspicious_patterns["ast_constant"]
        function_call: str = ast.unparse(node.func)
        args: str = " ".join([ast.unparse(arg) for arg in node.args])
        expr: str = ast.unparse(node)
        trace_path: list = self.tracer.trace_back(args)
        path: str = ""
        if trace_path:
            path = " ->".join(trace_path)
        for call_type in suspicious_calls:
            if self._is_malware(suspicious_calls[call_type], function_call):
                for constant_type in suspicious_const:  # Further confirmed by checking the arguments
                    if (
                        self._is_malware(suspicious_const[constant_type], args)
                        or IP().extract_public_ipv4(args)
                        or self._is_malware(suspicious_const[constant_type], Decryptor().base64_decode(args))
                    ):
                        self._summarize_analysis_detail(call_type, node.lineno, expr)
                        self.is_malware = True
                    elif self._is_malware(suspicious_const[constant_type], path):
                        self._summarize_analysis_detail(call_type, node.lineno, expr, path)
                        self.is_malware = True
        self.generic_visit(node)

    def visit_ClassDef(self, node: ast.ClassDef) -> None:  # noqa: N802 # pylint: disable=C0103
        """Visit the ClassDef node. This function is used to detect malicious behavior in setup.py."""
        if not node.bases:
            self.generic_visit(node)
            return

        for base in node.bases:
            if isinstance(base, ast.Name):
                if base.id == "install":
                    # TODO: Not pretty sure including this in setup.py means it is a malware, so the self.is_malware is not updated.
                    self.analysis_detail["Custom Setup"][node.lineno] = node.name
        self.generic_visit(node)

    def _summarize_analysis_detail(
        self, function_call_type: str, lineno: int, expr: str, trace_path: str | None = None
    ) -> None:
        """Store the analysis result in based on different type of malicious behaviour.

        Parameters
        ----------
        function_call_type: str
                The suspcious function call type.
        lineno: int
                The location of the source code block.
        expr: str
                The source code block.
        trace_path: str
                The dataflow path.
        """
        detail = [expr]

        if trace_path:
            detail.append(trace_path)

        match function_call_type:
            case "code_execution":
                self.analysis_detail["Code Execution"][lineno] = detail
            case "info_collecting":
                self.analysis_detail["Information Collecting"][lineno] = detail
            case "remote_connection":
                self.analysis_detail["Remote Connection"][lineno] = detail
            case "obfuscation":
                self.analysis_detail["Obfuscation"][lineno] = detail

    def _is_malware(self, malicious_pattern: list, target: str | None) -> bool:
        """Check the source code matched the suspicious pattern.

        Parameters
        ----------
        malicious_pattern: list
                A collection of the suspicious source code.
        target: str
                The componenet of the source code block.

        Returns
        -------
        bool
                The result.
        """
        if not target:
            return False
        for _ in malicious_pattern:  # pylint: disable=C0103, C0501
            if _ in target:
                return True
        return False

    def analyze(self, source_code: str) -> tuple[bool, dict]:
        """Analyze the source code."""
        tree = ast.parse(source_code)
        self.visit(tree)
        return self.is_malware, self.analysis_detail


class Decryptor:
    """This class includes multiple built-in decryption methods."""

    # Only decrypt the string with the built-in decrypt method; otherwise, provide the source code
    # for the user. And notify them to decrypt using the corresponding decrypt method
    # TODO: Implement more decryption method.

    def __init__(self) -> None:
        pass

    def base64_decode(self, encoded_value: str | bytes) -> str | None:
        """Decode the encoded value."""
        try:
            decoded_bytes = base64.b64decode(encoded_value)
            return decoded_bytes.decode("utf-8")
        except (binascii.Error, UnicodeDecodeError):
            return None


class IP:
    """This class provides the method to identify the IP in the source code."""

    def __init__(self) -> None:
        pass

    def is_valid_public_ipv4(self, ip: str) -> bool:
        """Check whether it is a public IPv4."""
        try:
            ip_obj = ipaddress.ip_address(ip)
            return ip_obj.version == 4 and not ip_obj.is_private and not ip_obj.is_loopback
        except ValueError:
            # If ip_address() raises an error, it's not a valid IP
            return False

    def extract_public_ipv4(self, text: str) -> list:
        """Extract the public IPv4 from the source code."""
        ipv4_pattern = r"\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b"
        all_ips = re.findall(ipv4_pattern, text)
        # Filter valid public IPv4 addresses
        valid_public_ipv4s = []
        for ip in all_ips:
            if self.is_valid_public_ipv4(ip):
                valid_public_ipv4s.append(ip)
        return valid_public_ipv4s
