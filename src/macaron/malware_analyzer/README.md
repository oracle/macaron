# Implementation of Malware Detector

## PyPI Ecosystem

Malware detection is achieved using a combination of metadata and source code heuristics. Certain combinations of the results of these heuristics are indicators of a malicious package.

When a heuristic fails, with `HeuristicResult.FAIL`, then that is an indicator by that heuristic of suspicious behaviour. When a heuristic passes, with `HeuristicResult.PASS`, then that is an indicator of benign behavior. When a heuristic is skipped, returning `HeuristicResult.SKIP`, then this means that heuristic was not applicable to the package, due to either package details or dependencies on other heuristics. When a heuristic encounters a malformed package, a `HeuristicAnalyzerValueError` is raised. The following heuristics are currently run sequentially to gauge package maliciousness.

1. **Empty Project Link**
   - **Description**: Checks whether the package contains any project links (e.g., documents or Git
   Repositories). Many malicious packages do not include any project links.
   - **Rule**: Return `HeuristicResult.FAIL` when there are no project links; otherwise, return `HeuristicResult.PASS`.

2. **Source Code Repo**
   - **Description**: Check's if Macaron was able to find a repository containing this package's source code (i.e., checks if
   one exists).
   - **Rule**: Return `HeuristicResult.FAIL` if no repository was found; otherwise, return `HeuristicResult.PASS`.
   - **Dependency**: Will be run if the Empty Project Link heuristic passes.

3. **One Release**
   - **Description**: Checks whether the package has only one release.
   - **Rule**: Return `HeuristicResult.FAIL` if the package contains only one release; otherwise, return `HeuristicResult.PASS`.

4. **High Release Frequency**
   - **Description**: Checks if the package released multiple versions within a short timeframe. We calculate
   the release frequency and define a default frequency threshold of 2 days.
   - **Rule**: Return `HeuristicResult.FAIL` if the frequency is higher than the threshold; otherwise, return `HeuristicResult.PASS`.
   - **Dependency**: Will be run if the One Release heuristic passes.

5. **Unchanged Release**
   - **Description**: Checks if the content of releases remains unchanged using the `sha256` digest of the package source.
   - **Rule**: Return `HeuristicResult.FAIL` if the content of any two releases is identical; otherwise, return `HeuristicResult.PASS`.
   - **Dependency**: Will be run if the High Release Frequency heuristic fails.

6. **Closer Release Join Date**
   - **Description**: Checks the gap between the date the maintainer(s) registered their account and the date
   of the latest release. A default threshold of 5 days is defined.
   - **Rule**: Return `HeuristicResult.FAIL` if the gap is less than the threshold for any maintainer; otherwise, return `HeuristicResult.PASS`.

7. **Suspicious Setup**
   - **Description**: Checks `setup.py` to see if there are suspicious imported modules, or
   `install_requires` packages that are installed during the package installation process. Current blacklisted packages are `base64` and `requests`. This heuristic is skipped if no `setup.py` file can be found in the package.
   - **Rule**: Return `HeuristicResult.FAIL` if the package name contains suspicious keywords; otherwise, return `HeuristicResult.PASS`.
   - **Dependency**: Will be run if the Closer Release Join Date heuristic fails.

8. **Wheel Absence**
   - **Description**: Checks for the presence of a wheel (`.whl`) file distributed with the specified package release.
   - **Rule**: Return `HeuristicResult.FAIL` if there is no wheel file present with that package release; otherwise, return `HeuristicResult.PASS`.

9. **Anomalous Version**
   - **Description**: Checks if the version number is abnormally high, checking the epoch and major version against threshold values. This does account for common date-based version number (calendar versioning) patterns.
   - **Rule**: Return `HeuristicResult.FAIL` if the major or epoch is abnormally high; otherwise, return `HeuristicResult.PASS`.
   - **Dependency**: Will be run if the One Release heuristic fails.

10. **Typosquatting Presence**
    - **Description**:  Checks if the package name is suspiciously similar to any package name in a predefined list of popular packages. The similarity check incorporates the Jaro-Winkler distance and considers keyboard layout proximity to identify potential typosquatting.
    - **Rule**: Return `HeuristicResult.FAIL` if the similarity ratio between the package name and any popular package name meets or exceeds a defined threshold; otherwise, return `HeuristicResult.PASS`.
    - **Dependency**: None.

    > **Note**: This heuristic relies on a list of popular packages stored in [`src/macaron/resources/popular_packages.txt`](../resources/popular_packages.txt). Maintainers should periodically update this list by running the [`find_packages.sh`](../../../scripts/find_packages.sh) script from the project root directory. This ensures the typosquatting detection remains effective against the latest popular packages.
    >
    > Example:
    > ```bash
    > ./scripts/find_packages.sh
    > ```
    > The script will download the top 5000 PyPI packages and update the resource file automatically.

11. **Similar Projects**
    - **Description**: Checks whether the maintainer(s) of the package have released other packages with close structural similarity.
    - **Rule**: Return 'HeuristicResult.FAIL` upon finding the first similar package. Return `HeuristicResult.PASS` if no similar packages are found.
    - **Dependency**: None

12. **Fake Email**
    - **Description**:  Checks if the package maintainer or author has a suspicious or invalid email.
    - **Rule**: Return `HeuristicResult.FAIL` if the email is invalid; otherwise, return `HeuristicResult.PASS`.
    - **Dependency**: None.

13. **Type Stub File**
    - **Description**: Checks if the package has a small number of `.pyi` stub files.
    - **Rule**: Return `HeuristicResult.FAIL` if the number of `.pyi` files is strictly less than FILES_THRESHOLD; otherwise, return `HeuristicResult.PASS`.
    - **Dependency**: None.

14. **Package Description Intent**
    - **Description**: Checks if the package description contains keywords indicating it is a stub package or dependency confusion prevention placeholder.
    - **Rule**: Return `HeuristicResult.FAIL` if no keyword is found in the package description or summary ; otherwise, return `HeuristicResult.PASS`.
    - **Dependency**: None.

15. **Stub Name**
    - **Description**: Checks if the package name contains the `"stub"` keyword, indicating that it is likely intended to be a stub package and not downloaded.
    - **Rule**: Return `HeuristicResult.PASS` if the keywork `"stub"` is found in the package name; otherwise, return `HeuristicResult.FAIL`.

### Source Code Analysis with Semgrep
**PyPI Source Code Analyzer**
- **Description**: Uses Semgrep, with default rules written in `src/macaron/resources/pypi_malware_rules` and custom rules available by supplying a path to `custom_semgrep_rules` in `defaults.ini`, to scan the package `.tar` source code.
- **Rule**: If any Semgrep rule is triggered, the heuristic fails with `HeuristicResult.FAIL` and subsequently fails the package with `CheckResultType.FAILED`. If no rule is triggered, the heuristic passes with `HeuristicResult.PASS` and the `CheckResultType` result from the combination of all other heuristics is maintained.
- **Dependency**: Will be run if the Source Code Repo fails. This dependency can be bypassed by supplying `--force-analyze-source` in the CLI.

This feature is currently a work in progress, and supports detection of code obfuscation techniques and remote exfiltration behaviors. It uses Semgrep OSS for detection. `defaults.ini` may be used to provide custom rules and exclude them:
- `disabled_default_rulesets`: supply to this a comma separated list of the names of default Semgrep rule files (excluding the `.yaml` extension) to disable all rule IDs in that file.
- `disabled_rules`: supply to this a comma separated list of individual rule IDs to disable (from both the default and custom list).
- `custom_semgrep_rules`: supply to this an absolute path to a directory containing custom Semgrep `.yaml` files to be run alongside the default ones.
- `disabled_custom_rulesets`: supply to this a comma separated list of the names of custom Semgrep rule files (excluding the `.yaml` extension) to disable all rule IDs in that file.

Here, a "semgrep ruleset" refers to the name of a Semgrep `.yaml` file without the extension. For example, the name of one of the default rulesets is `obfuscation`, as the file name is `obfuscation.yaml`. To disable all rules in that `.yaml` file would look like this:
```
disabled_default_rulesets = obfuscation
```
A "semgrep rule", or "rule ID", refers to an `- id` entry under the `rules:` heading in a Semgrep `.yaml` file. For example, the name of a rule in `obfuscation.yaml` would be `obfuscation_excessive-spacing`, which is the name specified under the `- id` entry for that rule. Disabling it would look like this:
```
disabled_rules = obfuscation_excessive-spacing
```

### Contributing

When contributing an analyzer, it must meet the following requirements:

- The analyzer must be implemented in a separate file, placed in the relevant folder based on what it analyzes ([metadata](./pypi_heuristics/metadata/) or [sourcecode](./pypi_heuristics/sourcecode/)).
- The analyzer must inherit from the `BaseHeuristicAnalyzer` class and implement the `analyze` function, returning relevant information specific to the analysis.
- The analyzer name must be added to [heuristics.py](./pypi_heuristics/heuristics.py) file so it can be used for rule combinations in [detect_malicious_metadata_check.py](../slsa_analyzer/checks/detect_malicious_metadata_check.py)
- The analyzer must be added to the list of analyzers in `detect_malicious_metadata_check.py` to be run.
- Update the `malware_rules_problog_model` in [detect_malicious_metadata_check.py](../slsa_analyzer/checks/detect_malicious_metadata_check.py) with logical statements where the heuristic should be included. When adding new rules, please follow the following guidelines:
   - Provide a [confidence value](../slsa_analyzer/checks/check_result.py) using the `Confidence` enum.
   - Ensure it is assigned to the `problog_result_access` string variable, otherwise it will not be queried and evaluated.
   - Assign a rule ID to the rule. This will be used to backtrack to determine if it was triggered.
   - Make sure to wrap pass/fail statements in `passed()` and `failed()`. Not doing so may result in undesirable behaviour, see the comments in the model for more details.
   - If there are commonly used combinations introduced by adding the heuristic, combine and justify them at the top of the static model (see `quickUndetailed` and `forceSetup` as current examples).

**Contributing Code Pattern Rules**

When contributing more Semgrep rules for `pypi_sourcecode_analyzer.py` to use, the following requirements must be met:

- Semgrep `.yaml` Rules are stored in `src/macaron/resources/pypi_malware_rules` and are named based on the category of code behaviors they detect.
- If the rule comes under one of the already defined categories, place it within that `.yaml` file, else create a new `.yaml` file using the category name.
- Each rule ID must be prefixed by the category followed by a single underscore ('_'), so for obfuscation rules in `obfuscation.yaml` each rule ID is prefixed with `obfuscation_`, followed by an ID which uses a hiphen ('-') as a separator.
- Tests must be written for each rule contributed. These are stored in `tests/malware_analyzer/pypi/test_pypi_sourcescode_analyzer.py`.
- These tests are written on a per-category bases, running each category individually. Each category must have a folder under `tests/malware_analyzer/pypi/resources/sourcecode_samples`.
- Within these folders, there must be sample code patterns for testing, and a file `expected_results.json` with the expected JSON output of the analyzer for that category.
- Each sample code pattern `.py` file must not have executable permissions and must include code that prevents it from being accidentally imported or run. The current files use this method:

```
"""
Running this code will not produce any malicious behavior, but code isolation measures are
in place for safety.
"""

import sys

# ensure no symbols are exported so this code cannot accidentally be used
__all__ = []
sys.exit()

def test_function():
    """
    All code to be tested will be defined inside this function, so it is all local to it. This is
    to isolate the code to be tested, as it exists to replicate the patterns present in malware
    samples.
    """
    sys.exit()
```

### Confidence Score Motivation

The original seven heuristics which started this work were Empty Project Link, Unreachable Project Links, One Release, High Release Frequency, Unchange Release, Closer Release Join Date, and Suspicious Setup. These heuristics (excluding those with a dependency) were run on 1167 packages from trusted organizations, with the following results:

| Heuristic Name   | Count |
|------------------| ----- |
| One Release      | 102   |
| Empty Link       | 45    |
| Links Missing    | 24    |
| Frequent Release | 14    |
| Suspicious Setup | 5     |

These results were used as a reference for the confidence score provided in each suspicious combination.
