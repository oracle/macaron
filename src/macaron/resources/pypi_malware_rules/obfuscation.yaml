# Copyright (c) 2025 - 2025, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

rules:
- id: obfuscation_inline-imports
  metadata:
    description: Detects use of inline imports with suspicious APIs, or obfuscated API imports.
  message: Found an instance of a suspicious API in a hardcoded inline import
  languages:
  - python
  severity: ERROR
  pattern-either:
  - pattern: __import__('base64')
  - pattern: __import__('builtins')
  - pattern: __import__('subprocess')
  - pattern: __import__('sys')
  - pattern: __import__('os')
  - pattern: __import__('zlib')
  - pattern: __import__('marshal')
    # python will evaluate a hex/oct string
  - patterns:
    - pattern: __import__('$HEX')
    - metavariable-regex:
        metavariable: $HEX
        regex: (\\x\d{2})+
  - patterns:
    - pattern: __import__('$OCT')
    - metavariable-regex:
        metavariable: $OCT
        regex: (\\\d{3})+

- id: obfuscation_obfuscation-tools
  metadata:
    description: Detects the use of common python obfuscation packages.
  message: Found an indicator of the use of a python code obfuscation tool
  languages:
  - python
  severity: ERROR
  pattern-either:
      # pyarmor: pyarmor.readthedocs.io/en/latest/index.html
  - pattern: import __pyarmor__
  - pattern: from $MODULE import __pyarmor__
  - pattern: from $MODULE import pyarmor_runtime
  - pattern: __import__('__pyarmor__')
      # pyarmor RTF mode: pyarmor.readthedocs.io/en/latest/tutorial/advanced.html
  - pattern: __assert_armored__($PAYLOAD)
      # inline pyarmor marker: pyarmor.readthedocs.io/en/latest/tutorial/advanced.html
  - pattern-regex: ^\s*#\s*pyarmor:.*
      # obfuscated names using pyob.oxyry.com with O, o, 0 or github.com/QQuick/Opy and pyobfuscate using l, I, 1
  - patterns:
    - pattern-either:
      - pattern: |
          def $OBF(...):
            ...
      - pattern: |
          class $OBF(...):
            ...
      - pattern: $OBF = ...
    - metavariable-regex:
        metavariable: $OBF
        regex: (^_*([lI1_]{5,}|[Oo0_]{5,})_*$)|(^pyarmor_*\d+$)
      # obfuscated using pyobfuscate.com
  - pattern: pyobfuscate=...
      # obfuscated using liftoff.github.io/pyminifier
  - pattern: import mystificate
  - pattern: import demiurgic

- id: obfuscation_decode-and-execute
  metadata:
    description: Detects the flow of a decoded or constructed string to process execution, code evaluation, network connections, or file writes.
  message: Detected the flow of a decoded primitive value to a remote endpoint, process, code evaluation, or file write
  languages:
  - python
  severity: ERROR
  mode: taint
  options:
    # This will help detect partial things over multiple lines like: "x = builtins.bytes; x.decode(...)"
    symbolic_propagation: true
  pattern-sources:
  - pattern-either:
        # marshal encryption
    - pattern: marshal.loads(...)
    - pattern: __import__('marshal').loads(...)
        # bytes decoding
    - pattern: |
        b'...'.decode(...)
    - pattern: bytes.decode(...)
    - pattern: builtins.bytes.decode(...)
    - pattern: __import__('builtins').bytes.decode(...)
        # decompression
    - pattern: zlib.decompress(...)
    - pattern: __import__('zlib').decompress(...)
        # base64 decoded string values
    - pattern: base64.b64decode(...)
    - pattern: __import__('base64').b64decode(...)
    - pattern: b64decode(...)
        # hex encoded values
    - pattern: bytes.fromhex(...)
    - pattern: builtins.bytes.fromhex(...)
    - pattern: __import__('builtins').bytes.fromhex(...)
        # unicode construction
    - patterns:
      - pattern-either:
        - pattern: $STRING.join(map($FOO, [...]))
        - pattern: $STRING.join($FOO($VAL) for $VAL in [...])
        - pattern: $STRING.join($FOO($VAL) for $VAL in $ITER)
        - pattern: $STRING.join($FOO($VAL) for $VAL in $GEN(...))
      - metavariable-regex:
          metavariable: $FOO
          regex: unicode|unichr|chr|ord

  pattern-sinks:
  - pattern-either:
        # process spawning
        # using subprocess module
    - pattern: subprocess.check_output(...)
    - pattern: subprocess.check_call(...)
    - pattern: subprocess.run(...)
    - pattern: subprocess.call(...)
    - pattern: subprocess.Popen(...)
    - pattern: subprocess.getoutput(...)
    - pattern: subprocess.getstatusoutput(...)
        # using os module
    - pattern: os.execl(...)
    - pattern: os.execle(...)
    - pattern: os.execlp(...)
    - pattern: os.execlpe(...)
    - pattern: os.execv(...)
    - pattern: os.execve(...)
    - pattern: os.execvp(...)
    - pattern: os.execvpe(...)
    - pattern: os.popen(...)
    - pattern: os.posix_spawn(...)
    - pattern: os.posix_spawnp(...)
    - pattern: os.spawnl(...)
    - pattern: os.spawnle(...)
    - pattern: os.spawnlp(...)
    - pattern: os.spawnlpe(...)
    - pattern: os.spawnv(...)
    - pattern: os.spawnve(...)
    - pattern: os.spawnvp(...)
    - pattern: os.spawnvpe(...)
    - pattern: os.system(...)
        # using commands module
    - pattern: commands.getstatusoutput(...)
    - pattern: commands.getoutput(...)
        # using runpy module
    - pattern: runpy.run_module(...)
    - pattern: runpy.run_path(...)

        # code evaluation/execution
    - pattern: exec(...)
    - pattern: eval(...)
    - pattern: builtins.exec(...)
    - pattern: builtins.eval(...)
    - pattern: __import__('builtins').exec(...)
    - pattern: __import__('builtins').eval(...)

- id: obfuscation_excessive-spacing
  metadata:
    description: Detects the use of excessive spacing in code, which may indicate obfuscation or hidden code.
  message: Hidden code after excessive spacing
  languages:
  - python
  severity: ERROR
  pattern-either: # The 50 here is the threshold for excessive spacing , more than that is considered obfuscation
    # there is excessive spacing after a ";", marking the end of a statement, then additional code.
  - pattern-regex: ;[\t ]{50,}(\S)+
    # there is excessive spacing before a ";", and any amount of whitespace before additional code.
  - pattern-regex: '[\t ]{50,};[\t ]*(\S)+'
